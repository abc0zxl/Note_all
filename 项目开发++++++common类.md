# Exception

**作用**：

* 给“AAAA”这个**提示业务**，起一个**专属的名字**
* 解决错误分不清的情况

**如果没有**：

* **报错原因不清晰**：遇到报错时，好的情况给异常设定具体值了，能通过设定的文字勉强知道是啥错了。
* ![image.png](/assets/b09ca823-cfd7-4a90-b661-23649bd284e7.png)
* **错误处理棘手**：由于只能通过传入的字符做出判断，要做哪些操作。
* **可读性差**：

**如果有**：

* **报错清晰**：有专门的类来抛出这个错误
* ![image.png](/assets/18b68655-013a-4e52-8666-2432efee4bb0.png)
* **错误处理便捷**：由于每个自定义的异常都是单独的文件，所以处理错误的时候直接在这个异常类里面编异常处理逻辑即可。比如：**返回错误码**
* ![image.png](/assets/1f465281-a0d9-46a1-9605-8d256476078c.png)
* **提高了代码的可读性**

**实际应用场景**：

![image.png](/assets/c738e54f-ea87-42ec-bb57-8a546daee209.png)

1.上面这个异常处理类包含了两个方法

* **无参构造方法**：默认提示时，调用的方法
* **有参构造方法**：这个是指传入了**义务场景提示**，

# Constant

他表示常量，用来存放公共信息的，

**作用**：统一管理自动填充时遇到的方法名，

* 避免硬编码
* 让代码更规范
* 更易维护

**应用场景**：

* **公共时间**：更新时间，创建时间
* **公共人**：创建人
* **需要加密的字段**：各种名字，各种id
* **文本提示信息**：提示框这种固定的文字
* **状态信息**：增加数字状态的可读性

# context

这个是**上下文**，存储用于上下文交互的逻辑

**BaseContext**：用于存放当前用户的线程操作。

# enumeration

枚举类型

# json时间序列化

**为什么要json序列化处理文件？**

* **原因**：如果没有，后端调用localdatatime存储到数据库的数据就是**乱的**，存的数组
* **后果**：前端获取数据，就无法将其再次转换为时间字符串，前端传递时间给后端就会**不认识**

![image.png](/assets/e443411f-cd83-409f-a25c-7f9ed39cb876.png)

* **添加json序列化类后**：

![image.png](/assets/cb65b5ce-0eb0-46fa-8840-f8fa3f2ef915.png)


**实体类中的@JsonFormat专门处理不同时间格式，他和上面的json序列化器什么关系？**

* **没关系**：没加这个的属性，就会按照上面全局的json序列化类处理
* **处理不同时间格式**：这个注解不需要这个全局json序列化类的处理，他能单独处理

![image.png](/assets/53de9ef2-cb3d-4574-87be-a3cafd0fcc10.png)

### json序列化类实现步骤

* **LocalDateTime**转

![image.png](/assets/d96eaed5-de26-435b-86e0-196696aaedf2.png)

* **序列化**：把java对象转换为JSON字符串
* **反序列化**：把JSON字符串转换为java对象

1.**序列化操作**：

![image.png](/assets/55b33237-dae0-4581-8985-f4337b83647f.png)

2.**反序列化**：

* 在默认情况下，反序列化（json转java对象）如果遇到json存在java中没有的参数，**就会报错**
* 所以需要一个方法，**解除掉这个方法**

3.**super（）**

**作用**：初始化序列化器里的各种方法

**位置**：在json序列化处理方法之前，局部区域只能，也就是第一条

4.**getDeserializationConfig()**：反序列化器的方法

5.**registerModule**：告诉jackson序列化器，不要用默认方法，要用自定义的方法

6.**代码总览**

![image.png](/assets/2f67cfb8-48a5-4ea6-a396-f55580e57dfa.png)

# properties

这个是配置类

1.**配置属性类**+**配置文件**：

* 他的作用步骤是
* **第一步**：将配置文件中的属性值，通过@configurationProperties映射过来，将配置属性类中的属性附上值，**他们有自己的匹配逻辑**

![image.png](/assets/731f5090-0ff6-4cd4-9f61-3d1f5eaafa15.png)

* **第二步**：将其交给spring容器管理

2.**两个例子**：jwt令牌配置类，微信小程序配置类

![image.png](/assets/82e861ec-b68e-466f-96a5-1c811a9c5dcb.png)

# result

这个是返回结果的类，他整合了经常需要返回的信息

1.**PageResult**：它封装了分页查询结果的类

# utils

这个是工具类，用来提供便利的操作的

1.**第三方云数据库连接工具**

2.**网络传输工具**

3.**jwt工具**

4.**微信支付工具**




















## 实现发送HTTP给前端

**原因**：springboot的注解只管接收前端发起的请求，而后端发送请求就需要自己编写http逻辑，就像前端编写axios一样

**作用**：不管是对接第三方接口（比如微信支付、短信服务）、调用内部微服务，还是访问外部 API，都会用到它

* 把复杂的apache httpclient请求简化为简单的（doget，dopost，dopost4json）
