# 首页修改

修改头部

![image.png](/assets/fe0ee2ea-8ce1-49d9-8748-074b2cd0e583.png)

# 导航

**图标库**：https://www.iconfont.cn/

![image.png](/assets/b212651c-99a9-4a13-9086-a1a1f2d228a8.png)

# 轮播图实现

1.**导入图片**：

![image.png](/assets/118dfa81-776b-402e-8842-0d56ab9c2c80.png)

2.**编写轮播逻辑**：这个是在index.vue编写的

* 有专用轮播标签：**<swiper-item》**
* 这个标签还要编写数据绑定用于换图片
* 这个轮播图相关功能可以查找官方文档

![image.png](/assets/4d7126e3-b37b-49a6-b738-859425589a80.png)

![image.png](/assets/28449ed7-cc96-4d58-8057-ffa4752e112d.png)

3.**编写轮播图的显示效果**：

* 首先在标签里加个类名，用于编写css时所用的名字
* 注意这里的.banner,.banner要严格这样编写
* ![image.png](/assets/58fbc3b4-ddd1-4a20-ad37-e9ad9a64aad9.png)

# 返回提示信息

![image.png](/assets/629a8e6b-8e8d-46b8-b4c9-69f8eca75aa4.png)1.**uni.showToast()**：这个是uni-app提供的跨端API，作用是再页面上弹出一个轻量级的提示框

2.**icon：’none‘**：指定提示框的图标样式为”无图标“，可以是**success**,**loading**

![image.png](/assets/978b037a-677e-4c66-89b9-515c6df0aeaf.png)

![image.png](/assets/332fac6d-ec78-4931-8a64-4ba8a2ad2941.png)

# 自定义导航栏

**原因**：不同的机型，顶部的显示效果不一样，有的好有的坏，所以要用到自定义导航栏

**实现步骤**

1.**导入别人的导航栏**：这个放到首页的文件夹下，用一个新的文件来存储这个导航栏组件

2.**在首页中导入这个组件**：

![image.png](/assets/a2a82a19-54c8-4c46-b89d-16753a7e0c3c.png)

3.**将原来的导航栏隐藏**：

* 在pages.json中
* 添加一个导航栏的风格声明

![image.png](/assets/21fc35cf-9a34-4155-b970-1388f26d9771.png)

## 安全区域

不同的机型他的安全区域不同，这个安全区域是表示不被顶部刘海，或右上角的推出按钮所阻挡的区域。

**![image.png](/assets/afadff41-85b8-450c-bdcc-771b4b61b561.png)**

1.**底部安全区域小程序已经帮我们处理好了**

2.**我们处理一下顶部的安全区域即可**，微信提供的数值单位是**px**

3.**然后根据导航栏的样式，再设置一下最顶部信息条的颜色，防止撞色**

### 获取顶部安全区域数值

![image.png](/assets/b7cfe821-3d1d-41c9-9e19-a7ee45804f38.png)

![image.png](/assets/24359b63-bcd2-4037-8576-cf3b1b2f19b5.png)

### 将原来的导航栏样式的顶部间隔设置为动态值

![image.png](/assets/95d5eaf3-754e-40d6-8757-7ef4c6a6c5a3.png)

在最外层的标签上

![image.png](/assets/11f8db5b-be12-4d9a-8fc8-966342b4f3d5.png)

### 修改顶部信息条字体颜色

![image.png](/assets/57dfb7c8-d788-4162-9669-93f12c9fac2e.png)

![image.png](/assets/cf47f8cc-601e-49e7-a8f2-a9c5303d9de8.png)

### 配置底色，用于和别的区域区别开

![image.png](/assets/5a74f95c-1012-4950-815c-a0fe5d4855b4.png)

### 配置每个分类的图标和标题

![image.png](/assets/505fd4b5-232c-44ad-a6a9-36727be51fa6.png)

### 推荐页面

![image.png](/assets/1820bbe4-702e-4757-a688-33566a266c49.png)

### 猜你喜欢模块

**通用组件都要放在src下的component中**：

### 页面滚动让上面的导航栏不动

上面的情况下滚动页面，上面的导航栏会跟着滚动走，而不是停留在上面

**关键字**：<scroll-view scroll-y》，css

**作用**：被他框住的部分会滚动，在外面的就不会跟着滚动

**方法**：

这个直接用模板

1.**先让page占满整页**

2.**显示模式调整为flex**

3.**告诉flex元素按照纵向排列**

4.**让要滚动的部分占满他标签内的所有页面**

![image.png](/assets/75a06541-2bb8-47ed-a9d1-a3ebe626f761.png)

## 组件生命周期加载数据

1.**性能问题**：猜你喜欢页面在页面滚动后才能看到，不滚动看不到，就是说如果没有往下翻，就不用加载

2.**加载时机**：当翻页后，可以在这个组件**挂载完毕**后再进行加载数据

3.**连续加载**：当继续往下翻时，实际上就是一组一组的加载，可以看作列表，可以设置**页码**，**页大小**

4.**代码编写位置**：上面几个分类，推荐都是只在一个页面，所以获取数据的API直接放在页面上就好了，这里的猜你喜欢，他可能出现在多个页面，**所以API放在组件内最合适**，

## 长列表的数据类型（会用到滑动加载的)

这种的类型是比较复杂的，因为向上面他是包含了**页码**，**页大小**，还有**商品**，

1.**类型结构**：他将页对象作为主要对象，这一页获取到的多个商品作为这个页对象的其中一个**泛型列表元素**

![image.png](/assets/1c240643-39de-4b4a-ab1e-4145711dfd9a.png)

## 长列表页面的显示

他的API调用是放在组件里的

由于主要想渲染商品列表，所以可以获取一个以**商品类型的响应式**，作为接收响应数据的容器，

1.**类型不一致**：由于响应的数据类型是**页类型**，商品结果列表是他的一个属性。所以要微微处理一下获取到这个列表

![image.png](/assets/3598fc4f-7c4f-46c1-a88b-1ab713f8db9f.png)

2.**调用组件挂载什么周期函数**：运行这个函数

![image.png](/assets/521e220f-22ec-4847-8792-865a02792010.png)

3.**注意**：由于接受的结果就是想要的那个列表类型，所以在v-for的位置不用在.list，直接用这个变量

![image.png](/assets/89f93f9f-00d5-4131-89cb-1f4f00ed1013.png)

## 滚动触底

1.滚动触底事件是在**滚动容器中**被触发的一个事件方法

* 利用该方法，去执行获取滚动加载数据
* 而执行该方法需要调用获取数据的方法

2.获取数据是在**猜你喜欢的组件中**的

3.**暴露组件中获取数据的方法**

4.**创建组件实例**，因为要调用组件中暴露出来的方法就要用这个组件对象，也叫**组件实例**，

* 用响应式来创建这个组件实例，这个组件实例类型在**类型文件中创建**

![image.png](/assets/009e6096-a83d-4ec1-a82d-f7754a014b73.png)

* 然后就可以调用这个创建的实例用.value**获取到暴露的方法**

![image.png](/assets/bc775ec6-f6fa-4279-a489-c572f341ec9b.png)

4.然后将该暴露的方法放在**滑动触底事件中**，用.value就能获取的该方法得到的数据

![image.png](/assets/6ccce81e-9a1e-4300-9e9f-0f2e50d486d1.png)

## **滚动数据加载**

1.**首先可以定义一个关于修改他页面的类型**：

* 指包含页码，页大小

2.**在发送请求的页面利用该类型的展开式赋值**：给后端传递这个参数，因为他会自动覆盖这部分参数

3.**获取到数据后，这个类型的参数自增，实现循环滚动页面的数据加载**

![image.png](/assets/b93d827c-b341-4af4-8b98-3aa8fdc60fbf.png)

## 滚动页面的停止加载

因为页面肯定会翻完，翻完再发送请求会浪费性能，所以要设计停止加载的逻辑

1.**将当页和后台的页总数进行判断就能判断**：将页自增放到这个判断逻辑中

2.**请求中断**：可以再else中修改一下外部的一个bool变量，然后将请求方法放在一个if中判断即可

## 下拉刷新效果

1.**下拉刷新**：这个是放在滚动容器中的一个**方法**![image.png](/assets/a997d0af-3f52-4d2a-88d6-27419305a723.png)

2.**下拉刷新的业务**：这个也是在**滚动容器**中的一个方法

![image.png](/assets/7a6ca1df-a821-4468-9579-eae3fa578b2a.png)

3.**封装请求**：将该页面的几个组件的获取数据方法都放到方法中

4.**关闭动画**：这个叫做处理下拉刷新的状态方法，也在**滚动容器中**

![image.png](/assets/82a92e75-ea23-4a78-9b92-700c7effb6d8.png)

* **请求前开启动画**
* **全球完成后关闭动画**
* 这个在放置的几个请求前后各放一个即可
* **注意**：这里肯定要等待这几个请求加载完毕才可以执行关闭加载动画
* 所以要用**等待，异步**，方法内的几个方法得等，外部方法要**标记为异步**

![image.png](/assets/8f46576d-c57f-4984-b786-2bedb64e2e81.png)

### 下拉刷新逻辑优化

1.下图三次等待都是排序进行的，浪费时间

![image.png](/assets/7db1351c-d814-4ae8-9873-f9ff5771dcfd.png)

2.**同步进行**：**Promise.all([])**，这个作用是里面的请求可以**同步进行**，

3.**等待请求**：让这个语句等待一次即可**完成优化**

![image.png](/assets/92747e07-e4e0-4dc7-af11-18222394367a.png)

### 下拉刷新重置数据

* .**不仅要重置数据**：
* **还要重置页码，结束标记，列表等标记**：

1.**在组件中编写重置函数**：

2.**到触发地调用该函数**：要用到**暴露方法**操作

![image.png](/assets/5e04c740-27b9-4caf-ba02-1913fdc7a22d.png)

### 骨架屏

在数据加载出来之前的一个组件影子

通过是否正在加载组件来判断是否要**显示骨架屏**

1.**生成基础代码**：

* 在微信小程序中的页面信息能找到

2.**复制粘贴到uniapp中**：

* 处理想要的那部分骨架即可

3.**处理代码**：他给的是这整个页面的代码

* 需要将导航条骨架部分删除
* 还有外部滚动框架删除，因为不滚动

![image.png](/assets/3ee004b4-81a2-41c5-bdbb-c9111626350e.png)

4.**处理报错**：如果有组件不显示的话，就调节一下高度样式，因为不适配他就不显示了

5.**将这个骨架放到导航条下面**

6.**编写显示逻辑**：**v-if**如果骨架部分的组件

* 正在加载中就显示
* 不在加载中就关闭

![image.png](/assets/b783bf66-90b9-4081-aa52-212714ce556a.png)

7.**这个判断放在**：原始加载位置生命周期函数的地方，头和尾放一个就好了。

* 最好用**整体加载+异步等待**

![image.png](/assets/0742b906-1fbe-4a4b-8cd8-5b9c19d9f6af.png)

## 动态设置页面标题

![image.png](/assets/0d9d2686-7c70-47e3-9c2e-6c133c2196ce.png)

## 页面显示效果控制

当前页**下标标记**，这个是利用了css控制的，有两个阶段控制css，

1.**双控制**：当调用了这个css类中的active时就会改变他的样式而达到显示效果

2.**所以要控制他显不显示，就调看他会不会调用这个active就知道**

![image.png](/assets/1f75aaf5-47c1-48e7-9999-421807c12032.png)**

![image.png](/assets/cd11a80d-2878-42b6-879a-4cdb5b1819f5.png)

3.**控制哪个标识显示**：

这里就要用到了**:class**方法控制这个class名字是否使用

* 如果点击了某个标签，这个标签中的@tap就会传递出去当前页的编号，
* 然后给这个：class方法判断，
* ![image.png](/assets/9886bea5-3df6-436a-b630-fa4aaf828777.png)

## 同一页中的列表切换

这种情况，就是说，是在同一页中的列表切换**反复切换**，如果要保持好性能，就同时加载这几个列表，然后**选择其中一个展示**

1.**条件展示**

* 这里就不用if-else了，用**if-show**

### v-show

这个的适用场景**如上**。

### 编列对象时获取当前对象下标位置技巧

**v-for="(item,index) in items"**：这个index就是这个items数组中获取当前组员的下标




### 大图预览API

![image.png](/assets/48aabd22-3e04-42aa-ad43-d49953d87755.png)

1.**他会自己处理好内部数字，排序等逻辑，所以要传递给他所有图片**

![image.png](/assets/dde23e43-734a-4370-b0a1-ec5e0d870c11.png)

## 弹出服务说明

这个有现成的API，弹出层组件文档
