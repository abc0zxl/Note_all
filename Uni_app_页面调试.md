# 首页修改

修改头部

![image.png](/assets/fe0ee2ea-8ce1-49d9-8748-074b2cd0e583.png)

# 导航

**图标库**：https://www.iconfont.cn/

![image.png](/assets/b212651c-99a9-4a13-9086-a1a1f2d228a8.png)

# 轮播图实现

1.**导入图片**：

![image.png](/assets/118dfa81-776b-402e-8842-0d56ab9c2c80.png)

2.**编写轮播逻辑**：这个是在index.vue编写的

* 有专用轮播标签：**<swiper-item》**
* 这个标签还要编写数据绑定用于换图片
* 这个轮播图相关功能可以查找官方文档

![image.png](/assets/4d7126e3-b37b-49a6-b738-859425589a80.png)

![image.png](/assets/28449ed7-cc96-4d58-8057-ffa4752e112d.png)

3.**编写轮播图的显示效果**：

* 首先在标签里加个类名，用于编写css时所用的名字
* 注意这里的.banner,.banner要严格这样编写
* ![image.png](/assets/58fbc3b4-ddd1-4a20-ad37-e9ad9a64aad9.png)

# 返回提示信息

![image.png](/assets/629a8e6b-8e8d-46b8-b4c9-69f8eca75aa4.png)1.**uni.showToast()**：这个是uni-app提供的跨端API，作用是再页面上弹出一个轻量级的提示框

2.**icon：’none‘**：指定提示框的图标样式为”无图标“，可以是**success**,**loading**

![image.png](/assets/978b037a-677e-4c66-89b9-515c6df0aeaf.png)

![image.png](/assets/332fac6d-ec78-4931-8a64-4ba8a2ad2941.png)

# 自定义导航栏

**原因**：不同的机型，顶部的显示效果不一样，有的好有的坏，所以要用到自定义导航栏

**实现步骤**

1.**导入别人的导航栏**：这个放到首页的文件夹下，用一个新的文件来存储这个导航栏组件

2.**在首页中导入这个组件**：

![image.png](/assets/a2a82a19-54c8-4c46-b89d-16753a7e0c3c.png)

3.**将原来的导航栏隐藏**：

* 在pages.json中
* 添加一个导航栏的风格声明

![image.png](/assets/21fc35cf-9a34-4155-b970-1388f26d9771.png)

## 安全区域

不同的机型他的安全区域不同，这个安全区域是表示不被顶部刘海，或右上角的推出按钮所阻挡的区域。

**![image.png](/assets/afadff41-85b8-450c-bdcc-771b4b61b561.png)**

1.**底部安全区域小程序已经帮我们处理好了**

2.**我们处理一下顶部的安全区域即可**，微信提供的数值单位是**px**

3.**然后根据导航栏的样式，再设置一下最顶部信息条的颜色，防止撞色**

### 获取顶部安全区域数值

![image.png](/assets/b7cfe821-3d1d-41c9-9e19-a7ee45804f38.png)

![image.png](/assets/24359b63-bcd2-4037-8576-cf3b1b2f19b5.png)

### 将原来的导航栏样式的顶部间隔设置为动态值

![image.png](/assets/95d5eaf3-754e-40d6-8757-7ef4c6a6c5a3.png)

在最外层的标签上

![image.png](/assets/11f8db5b-be12-4d9a-8fc8-966342b4f3d5.png)

### 修改顶部信息条字体颜色

![image.png](/assets/57dfb7c8-d788-4162-9669-93f12c9fac2e.png)

![image.png](/assets/cf47f8cc-601e-49e7-a8f2-a9c5303d9de8.png)

### 配置底色，用于和别的区域区别开

![image.png](/assets/5a74f95c-1012-4950-815c-a0fe5d4855b4.png)

### 配置每个分类的图标和标题

![image.png](/assets/505fd4b5-232c-44ad-a6a9-36727be51fa6.png)

### 推荐页面

![image.png](/assets/1820bbe4-702e-4757-a688-33566a266c49.png)

### 猜你喜欢模块

**通用组件都要放在src下的component中**：

### 页面滚动让上面的导航栏不动

上面的情况下滚动页面，上面的导航栏会跟着滚动走，而不是停留在上面

**关键字**：<scroll-view scroll-y》，css

**作用**：被他框住的部分会滚动，在外面的就不会跟着滚动

**方法**：

这个直接用模板

1.**先让page占满整页**

2.**显示模式调整为flex**

3.**告诉flex元素按照纵向排列**

4.**让要滚动的部分占满他标签内的所有页面**

![image.png](/assets/75a06541-2bb8-47ed-a9d1-a3ebe626f761.png)

## 组件生命周期加载数据

1.**性能问题**：猜你喜欢页面在页面滚动后才能看到，不滚动看不到，就是说如果没有往下翻，就不用加载

2.**加载时机**：当翻页后，可以在这个组件**挂载完毕**后再进行加载数据

3.**连续加载**：当继续往下翻时，实际上就是一组一组的加载，可以看作列表，可以设置**页码**，**页大小**

4.**代码编写位置**：上面几个分类，推荐都是只在一个页面，所以获取数据的API直接放在页面上就好了，这里的猜你喜欢，他可能出现在多个页面，**所以API放在组件内最合适**，

## 长列表的数据类型（会用到滑动加载的)

这种的类型是比较复杂的，因为向上面他是包含了**页码**，**页大小**，还有**商品**，

1.**类型结构**：他将页对象作为主要对象，这一页获取到的多个商品作为这个页对象的其中一个**泛型列表元素**

![image.png](/assets/1c240643-39de-4b4a-ab1e-4145711dfd9a.png)

## 长列表页面的显示

他的API调用是放在组件里的

由于主要想渲染商品列表，所以可以获取一个以**商品类型的响应式**，作为接收响应数据的容器，

1.**类型不一致**：由于响应的数据类型是**页类型**，商品结果列表是他的一个属性。所以要微微处理一下获取到这个列表

![image.png](/assets/3598fc4f-7c4f-46c1-a88b-1ab713f8db9f.png)

2.**调用组件挂载什么周期函数**：运行这个函数

![image.png](/assets/521e220f-22ec-4847-8792-865a02792010.png)

3.**注意**：由于接受的结果就是想要的那个列表类型，所以在v-for的位置不用在.list，直接用这个变量

![image.png](/assets/89f93f9f-00d5-4131-89cb-1f4f00ed1013.png)

## 滚动触底

1.滚动触底事件是在**滚动容器中**被触发的一个事件方法

* 利用该方法，去执行获取滚动加载数据
* 而执行该方法需要调用获取数据的方法

2.获取数据是在**猜你喜欢的组件中**的

3.**暴露组件中获取数据的方法**

4.**创建组件实例**，因为要调用组件中暴露出来的方法就要用这个组件对象，也叫**组件实例**，

* 用响应式来创建这个组件实例，这个组件实例类型在**类型文件中创建**

![image.png](/assets/009e6096-a83d-4ec1-a82d-f7754a014b73.png)

* 然后就可以调用这个创建的实例用.value**获取到暴露的方法**

![image.png](/assets/bc775ec6-f6fa-4279-a489-c572f341ec9b.png)

4.然后将该暴露的方法放在**滑动触底事件中**，用.value就能获取的该方法得到的数据

![image.png](/assets/6ccce81e-9a1e-4300-9e9f-0f2e50d486d1.png)

## **滚动数据加载**

1.**首先可以定义一个关于修改他页面的类型**：

* 指包含页码，页大小

2.**在发送请求的页面利用该类型的展开式赋值**：给后端传递这个参数，因为他会自动覆盖这部分参数

3.**获取到数据后，这个类型的参数自增，实现循环滚动页面的数据加载**

![image.png](/assets/b93d827c-b341-4af4-8b98-3aa8fdc60fbf.png)

## 滚动页面的停止加载

因为页面肯定会翻完，翻完再发送请求会浪费性能，所以要设计停止加载的逻辑

1.**将当页和后台的页总数进行判断就能判断**：将页自增放到这个判断逻辑中

2.**请求中断**：可以再else中修改一下外部的一个bool变量，然后将请求方法放在一个if中判断即可

## 下拉刷新效果

1.**下拉刷新**：这个是放在滚动容器中的一个**方法**![image.png](/assets/a997d0af-3f52-4d2a-88d6-27419305a723.png)

2.**下拉刷新的业务**：这个也是在**滚动容器**中的一个方法

![image.png](/assets/7a6ca1df-a821-4468-9579-eae3fa578b2a.png)

3.**封装请求**：将该页面的几个组件的获取数据方法都放到方法中

4.**关闭动画**：这个叫做处理下拉刷新的状态方法，也在**滚动容器中**

![image.png](/assets/82a92e75-ea23-4a78-9b92-700c7effb6d8.png)

* **请求前开启动画**
* **全球完成后关闭动画**
* 这个在放置的几个请求前后各放一个即可
* **注意**：这里肯定要等待这几个请求加载完毕才可以执行关闭加载动画
* 所以要用**等待，异步**，方法内的几个方法得等，外部方法要**标记为异步**

![image.png](/assets/8f46576d-c57f-4984-b786-2bedb64e2e81.png)

### 下拉刷新逻辑优化

1.下图三次等待都是排序进行的，浪费时间

![image.png](/assets/7db1351c-d814-4ae8-9873-f9ff5771dcfd.png)

2.**同步进行**：**Promise.all([])**，这个作用是里面的请求可以**同步进行**，

3.**等待请求**：让这个语句等待一次即可**完成优化**

![image.png](/assets/92747e07-e4e0-4dc7-af11-18222394367a.png)

### 下拉刷新重置数据

* .**不仅要重置数据**：
* **还要重置页码，结束标记，列表等标记**：

1.**在组件中编写重置函数**：

2.**到触发地调用该函数**：要用到**暴露方法**操作

![image.png](/assets/5e04c740-27b9-4caf-ba02-1913fdc7a22d.png)

### 骨架屏

在数据加载出来之前的一个组件影子

通过是否正在加载组件来判断是否要**显示骨架屏**

1.**生成基础代码**：

* 在微信小程序中的页面信息能找到

2.**复制粘贴到uniapp中**：

* 处理想要的那部分骨架即可

3.**处理代码**：他给的是这整个页面的代码

* 需要将导航条骨架部分删除
* 还有外部滚动框架删除，因为不滚动

![image.png](/assets/3ee004b4-81a2-41c5-bdbb-c9111626350e.png)

4.**处理报错**：如果有组件不显示的话，就调节一下高度样式，因为不适配他就不显示了

5.**将这个骨架放到导航条下面**

6.**编写显示逻辑**：**v-if**如果骨架部分的组件

* 正在加载中就显示
* 不在加载中就关闭

![image.png](/assets/b783bf66-90b9-4081-aa52-212714ce556a.png)

7.**这个判断放在**：原始加载位置生命周期函数的地方，头和尾放一个就好了。

* 最好用**整体加载+异步等待**

![image.png](/assets/0742b906-1fbe-4a4b-8cd8-5b9c19d9f6af.png)

## 动态设置页面标题

![image.png](/assets/0d9d2686-7c70-47e3-9c2e-6c133c2196ce.png)

## 页面显示效果控制

当前页**下标标记**，这个是利用了css控制的，有两个阶段控制css，

1.**双控制**：当调用了这个css类中的active时就会改变他的样式而达到显示效果

2.**所以要控制他显不显示，就调看他会不会调用这个active就知道**

![image.png](/assets/1f75aaf5-47c1-48e7-9999-421807c12032.png)**

![image.png](/assets/cd11a80d-2878-42b6-879a-4cdb5b1819f5.png)

3.**控制哪个标识显示**：

这里就要用到了**:class**方法控制这个class名字是否使用

* 如果点击了某个标签，这个标签中的@tap就会传递出去当前页的编号，
* 然后给这个：class方法判断，
* ![image.png](/assets/9886bea5-3df6-436a-b630-fa4aaf828777.png)

## 同一页中的列表切换

这种情况，就是说，是在同一页中的列表切换**反复切换**，如果要保持好性能，就同时加载这几个列表，然后**选择其中一个展示**

1.**条件展示**

* 这里就不用if-else了，用**if-show**

### v-show

这个的适用场景**如上**。

### 编列对象时获取当前对象下标位置技巧

**v-for="(item,index) in items"**：这个index就是这个items数组中获取当前组员的下标

### 大图预览API

![image.png](/assets/48aabd22-3e04-42aa-ad43-d49953d87755.png)

1.**他会自己处理好内部数字，排序等逻辑，所以要传递给他所有图片**

![image.png](/assets/dde23e43-734a-4370-b0a1-ec5e0d870c11.png)

## 弹出服务说明

这个有现成的API，弹出层组件文档

**功能**

1.**弹出方式**：

* 中部弹出
* 底部弹出

2.**主窗口背景色**

3.**是否适配安全区**

4.**开关弹出层**

### 设置弹窗组件

1.**popup**：弹出方法

2.**background-color**：弹出后的背景颜色

![image.png](/assets/f88e538e-3e28-4b6b-99e5-18903be25760.png)

### 设置弹出层方法

这个包含上面的**功能**

1.**这个用组件中自动生成的响应式方法**：popup

2.**设置开关**：这个打开方式位置可以设置**弹出位置**

![image.png](/assets/9d423212-bf54-4303-ba1d-aa71b94c0aaa.png)

![image.png](/assets/e720f13d-dcc4-4152-85b1-e2ef948d80f5.png)

3.**调用开关**：上面设置了联合类型，调用时就能使用到

![image.png](/assets/4325dd45-acc4-471a-b817-983e7fb74fc1.png)

4.**也可以再多个位置设定弹出位置**

![image.png](/assets/673d8670-bbab-415b-b775-6128a4dd51f0.png)

## 弹出层具体实现

1.**编写弹出视图层(渲染层)**：

* **安全性**：用双向识别方式，这边等待着**特定的字符串**
* **判断语句**：通过**传递过来的弹窗名**，判断弹出特定的窗口，

![image.png](/assets/37d8363f-8c5d-4290-995c-2066845bcb75.png)

2.**编写开关（逻辑模板）**：

* 编写**判断用的变量**：popupName
* **编写开关**：调用popup的开关
* 可以指定开启类型，只能用top,bottom

![image.png](/assets/51318d57-ae2c-4f82-ac89-df2163a807e1.png)

3.**编写子面板（这个是弹窗代码）**

* 这个是编写**关闭按钮的地方**
* 用了**子调父的技术**，将获取到的关闭信息，通过**defineEmits**定义的close事件，**表示可以通过这个子组件来触发父组件的一些方法**

![image.png](/assets/f6727b22-1969-4c83-8a20-5ad68fae6659.png)

* 一旦触发emit('close')
* **父组件就会收到**，并执行关闭弹窗命令命令

![image.png](/assets/e3ff150e-b4c3-4f62-9357-4cd689d16ed8.png)

* 上面的@close就是**子组件定义的一个事件**，

![image.png](/assets/198efae6-59be-4a7e-b120-28fc36662b04.png)

## 登录信息的保存和立即跳转

### 持久化保存

这个用到了pinia，

### 跳转页面

1.这里uniapp提示**跳转到Taber页面**必须要用**switchTab**

2.还提示**跳转到Taber页面**会立即**屏蔽所有非Taber页面**

* 所以会出现，登录动画效果不友好，**就闪一下**

![image.png](/assets/1b039afc-f6c5-4ef8-8422-2d11e494d398.png)

## 模态弹窗

**退出登录提示框**：

* 是：跳转到我的页面
* 否：仅关闭提示框
* **是否展示提示框**：pinia有用户信息就展示没有就不展示

## 文件上传

1.**查看原始照片**

2.**添加点击事件**：

3.**调用API**：uni.chooseMedia，这个可以**拍照**，**选择图片**

4.**编辑API参数**：

* 文件个数
* 文件类型
* 成功逻辑

5.**编写上传参数**：

* 文件路径：
* 上传地址
* 文件名字

6.**判断逻辑**

## 地址列表

这个还是正常的显示，但是在触发显示上要做一些改动

1.**原来是放在onLoad上加载的**

2.**但是他有新增地址的功能**

3.**如果新增了地址后，这个处于onLoad加载，并不会再次去加载**

4.**所以要变换一下加载方式**

5.**换成onShow**,每一次打开页面的时候都会加载列表

## 表单校验uni-forms

这个编写位置是直接替换掉原来单view字段即可

在uniapp中，它提供了一个专门用于表单校验的标签，他能

* 绑定规则：v-rules
* 绑定属性对象：v-model
* 绑定数据：name
* 提示信息：placeholder

1.**绑定规则**：采用**选项式api编写方式**

* 可定义错误警告信息：errorMessage
* 字段规则，以下就是
* **必填**：required:true
* **长度规则**：minLength，maxLength

2.**表单校验属性**：这个的作用是调用表单验证的功能，**实行表单验证**

* **创建表单实例**
* ![image.png](/assets/2c70d5e2-ce61-432b-bc6d-1f2a92881cdf.png)
* **表单校验的主要执行代码**：管理着校验的周期
* ![image.png](/assets/326f5db2-d9e7-4a17-9a14-a7383658e9e9.png)

3.**利用正则来验证**：当这个表单校验中原始提供的校验方法不再满足需求时，就利用正则来表示

* **激活提示**：在校验规则对象属性中，声明整个校验规则的**类型**，这样编写规则**关键字**的时候就会有提示
* **启用正则表示式**：pattern：

![image.png](/assets/5af87b9c-8b46-49c0-bdd5-7bd8b5283b2c.png)



## 删除地址

**uniapp提供了以中国删除动画**，**侧滑删除**

![image.png](/assets/9eda5d64-d78f-46f1-949b-11cd0c939e94.png)

1.**侧滑删除标签结构**

![image.png](/assets/e1e3b198-49d6-4389-8df3-229e95d2d00d.png)

2.**在微信小程序端遇到依赖被忽略的报错时**：

* 去本地设置关闭过滤依赖


## SKU存货单位
