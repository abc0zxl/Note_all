# 注意

1.`接口请求是异步操作，需要用async/await

# 





# Uni-app

他是一个**使用Vue.js开发**所有的前端应用框架

**简单点说他是一个依附于Vue框架的一个综合性开发框架**

**作用**：写**一套代码**，就能发布到IOS，Android,Web（响应式），以继各种小程序，等**多种平台**

**特点**：

* **90%**的代码写法和vue框架一致

# **使用方法**

1.**安装Node.js**：最好选择双数版本

2.**去Uni-app的官网**：查看创建uni-app的命令

* 项目创建流程有点像Vue
* **第一步**：直接去这个官网提示的gitee下载
* **第二步**：导入依uniapp赖包**在命令行运行npm i**
* **第一步**：或者直接在HBuilder创建，
* **第二步**：然后下载uniapp（vue3）**编译器**，**这个用于跨端运行用的**

3.**运行**：在Hbuilder中点击上面的运行，选择浏览器运行即可

* 用命令运行的话可以参考目录下的**package.json**
* 其中dev的脚步适合开发用，build适合部署上线用
* 用npm 开头再接上双引号里的内容，就行了，这里运行了dev-weixin
* 然后会生成一个dist文件，用微信小程序打开里面的mp-weixin即可

4.需要从main.js这个代码处开始运行

# 模板调用

在Hbuilder中的新建项目界面,右上角有一个**去搜索**按钮,可以搜到更多模板

# API接口

#### 地图导航API接口

app中的地图界面,导航等都是用了地图平台的API实现的

#### 二维码创建接口

这个是微信小程序官方的,客户扫描二维码,就可以跳转到这个小程序

# 目录结构

**这里分为多种**

* 如果仅适用于微信小程序的话结构就比较简单
* **不同的需求**：如果要实现多端适应的话结构就会复杂一些，**会多出一些文件夹**
* **不同的创建方式**：通过HbuilderX创建的就比较简易一些，用CLI命令创建的就会复杂一些
* **团队定制**：在开发过程中会更具业务扩展出一些性的文件夹，：**接口、工具、状态管理、公共组件**

1.**uni.scss**：css编译器

2.**pages.json**：**配置页面路由**的地方，导航栏，tabBar等页面类信息（启动页）。

3.**main.js**：是vue应用的**入口文件**，程序启动时的第一个执行的js文件。启动这个vue的时候，就要从它开始启动，相当于spring里的application。

* 导入核心依赖
* 配置全局选项
* 创建vue根实例
* 最终将App.vue挂载到DOM上

4.**App.vue**：负责**全局布局**和**顶层组件承载**，不处理应用的启动配置

* 负责承载全局布局
* 所以他被称为组件树的根
* 用于关联所有子组件

5.**manifest.json**：配置appid、应用名称、logo、版本等打包信息，**在用微信小程序打开时需要在里面配置AppID**

6.**index.html**：H5端页面（**H5:基于HTML5开发的网页端应用**），可以直接运行在各种浏览器中，仅在用浏览器打开时会用到。是一个容器

7.**static文件夹**：用于引用的本地静态资源的文件夹，**静态资源只能放在这里**

8.**index.vue**：是某个页面，组件的具体实现文件，是编写业务逻辑，页面，样式的核心文件。

9.**pages文件夹**：存放页面的地方，采用右键创建的方式

* 他会顺便将框架创建好
* 还会把路由添加到pages.json中

10.**.eslintrc.cjs**（警官）：他是ESLint配置文件，负责检查代码质量

11.**.perttierrc.json**（化妆师）：Prettier配置文件，负责代码排版，不管代码加没加分号，缩进是否规范，一保存就会自动帮弄成统一的样子

* 它通常和eslintrc.cjs配合，

12.**.editorconfig**（桌椅标准）：告诉vs，这个项目的基本编码格式

* 因为有的人的编辑器设置不一样，
* 这个文件就是完成**强制统一的作用**
* 例如按下tab就相当于两个空格

13.**.husky**(安检门)：一个git hooks工具，当提交代码时，Husky会拦截，并运行npm run lint-staged

* 他会强制运行上面的ESLint和Prettier,
* 如果代码格式不对他就会阻止提交代码，
* 保证上交git的代码都是对的。

14.**services**（通讯员）：用于存放”网络请求“的代码

* 就是说不要把用户和后端交互的代码放到**页面（.vue）**里面，应该单独放到一个统一的地方（**services**）
* 作用就是提高相同代码的重用性，

15.**stores**（大仓库）：作用是**状态管理**，用于存放全局共享的数据

* 登录注册的token
* 购物车的商品列表
* **这些数据都是每个页面都要用的，放到这个地方每个页面都能读取和修改**

16.**types**(字典)：用于存放TypeScript的类型定义，定义了**实体类信息**，用于代码提示，在使用某个类**如商品**，就会提示它的属性是什么，防止写错

17.**styles**(装修队）：用于存放公共的css/scss样式文件，比如专门修改时字体的文件。fonts.scss

18.**uni.scss**(uni特供的变量)：这里定义scss变量

19.**env.d.ts**（TS翻译官）：TS默认只认识.ts文件，别的文件格式需要给他声明一下，如png，.vue

20.**pnpm-lock.yaml**（货物清单）：依赖包和版本锁定的文件

* 确保在自己电脑上跑的项目，到别的地方他的配置也是相同的也能跑

## 语法规则

#### 属性绑定

1.**原来是**：src="{url}"

2.**现在是**：src="url"

#### 事件绑定

1.**升级**：直接用@提示即可

![image.png](/assets/0ea3a019-6903-43c7-bda3-5a5668efa99a.png)

#### 支持vue常用指令

* vue3支持vue2的**选项式的语法**
* uniapp也支持vue的**常用语法**

#### VSCode插件

1.**支持Ts检错**

2.**插件支持快捷生成框架**：uni-create-view

3.**快速生成uni代码提示**：uni-helper,下方的那个

4.**便捷查标签文档**：	uuniapp小程序扩展

5.**ts类型校验**：命令行安装类型声明文件，如下图所示

6.**配置tsconfig.json**：这个有模板，把types中三个个绿的移过来即可，如下图所示

![image.png](/assets/f25738d0-f066-4990-99d2-d07f3247f6b5.png)

7.**json注释报错问题**：

* 设置里
* 文件管关联：
* 添加注释报错的文件放进去。

![image.png](/assets/d804112a-2f71-4a8c-806a-bade3ee230c0.png)

## uni-ui

他的作用是自动导入组件库

**实现步骤**：

1.**导入uni-ui**：npm i @dcloudio/uni-ui

2.**配置easycom**：在pages.json中导入依赖

![image.png](/assets/fe8e703f-d62c-4937-9cad-9a1d45a59cce.png)

3.**鼠标悬停提示效果**：

* 在上面鼠标悬停显示的似乎undefine，不识别
* **实现步骤**
* **第一步**：npm i -D @uni-helper/uni-ui-types

# Pinia持久化

**作用**：他是官方提供的一个用于

* 共享数据
* 集中管理
* 更新项目中的多个组件
* 组件之间只能单向传递，解决了多组件传递数据的难题

### **使用步骤**

1.**导入pinia**：

2.**创建pinia实例**：

3.**使用pinia持久化插件**：

4.**导出pinia**：

![image.png](/assets/6cea3335-a104-4f8d-ae00-c301b8f61cbd.png)

5.**导入实例**：因为后续要使用的依赖都必须在main.ts说明一下，这样后面的程序才能用到。

6.**启用pinia**：

![image.png](/assets/e30ad7e6-e9e0-4735-832b-4b2a2a93a3ea.png)

7.**使用pinia**：

* 将这个会员信息持久化到本地
* 这里的持久化方法要改一下，因为**网页端适配**，和**小程序适配**的表示方法不一样
* ![image.png](/assets/009aeca2-c65c-4494-8db5-28882c6b6547.png)
* ![image.png](/assets/72e11bdf-7aa9-44f3-b45f-a8d103e65aa3.png)

8.**查看持久化的信息**

* 微信小程序的**调试器**中， 的storage中

# 拦截器

## 拦截request请求

**作用**：

* 拼接请求头
* 设置超时事件
* 添加小程序的请求头表示
* 添加token的请求头标识

### 实现步骤

1.添加拦截器

2.添加触发器：拦截前触发

![image.png](/assets/33fd75b4-0e90-4688-8464-148a06b3bfc1.png)

### 拼接请求头

因为地址的头一个部分会被放到一个地方，有利于修改，所以在请求发出去前，请求会被拦截把他的地址补全

![image.png](/assets/ffcd22fe-4d4a-408e-afd4-dcbd3c739fb9.png)

### 设置超时时间

![image.png](/assets/f643e2e0-1c2f-4677-8d63-1daf2731939c.png)

### 添加小程序的请求头标识

* 第一句表示直接调用原来的header，如果不存在的话，就拼接第二句。

![image.png](/assets/6f13d311-789b-4b7b-900f-b10d61365b00.png)

### 添加token的请求头标识

![image.png](/assets/2cf9be05-c72c-40f7-8cfc-737d4deff226.png)

### 将拦截器添进去

* 表示发送request，发送uploadFile都启用这个拦截器

![image.png](/assets/55e3c83e-ca89-4533-b851-7b1f37479395.png)

## 请求函数的封装

为了更加便捷的发送请求，为其设置请求成功和请求失败的逻辑，

* 自动提取返回值
* 请求失败的妥善处理，返回失败原因

### 提取成功的情况下返回的核心数据

**实现步骤**：

1.**制作框架**：一个用于发送请求的框架

![image.png](/assets/2f08dd36-bca5-435a-a617-242e2a929101.png)

2.**编写返回响应的结果**

* 这里用的Promise对象
* 设置了一个回调函数

3.当request成功时就会调用resolve返回**主体数据**

4.**泛型**：这里还要注意返回结果类型的问题。返回的response中，只有result的类型是不固定的。可以利用泛型触底类型来定义返回出去的result类型

5.**异步等待**：由于这个是在利用外部工具类实现的请求，所以要加上，同步，异步

* 在获取响应数据的地方**等待**
* 在方法外部用**异步**

![image.png](/assets/e4610741-da16-4330-89d2-aeb5da2a6e01.png)

![image.png](/assets/8f673070-8202-4f7d-9356-340a03b0ea03.png)

#### 注意

1.**这里说的请求成功**：是指这个请求成功发出去了，**收到了响应的成功**，并不是成功获取到数据的成功

* 未携带token，这个时候可以收到响应，但是，不是常说的成功的请求。
* 等等……
* 只有状态码为200的才叫获取成功
* 所以要将这些请求分离出去，按照失败来处理
* file一般是说**没有网络**

#### 升级的请求函数封装

1.**沿用axios判断规则**：状态码200~299表示成功，成功才调用resolve

![image.png](/assets/64fb4d7a-4e78-4223-a3ea-bf6e64e29960.png)

![image.png](/assets/99644feb-7444-41ba-bbc1-70e3b0b9e63d.png)

#### 返回提示信息

![image.png](/assets/629a8e6b-8e8d-46b8-b4c9-69f8eca75aa4.png)1.**uni.showToast()**：这个是uni-app提供的跨端API，作用是再页面上弹出一个轻量级的提示框

2.**icon：’none‘**：指定提示框的图标样式为”无图标“，可以是**success**,**loading**

![image.png](/assets/978b037a-677e-4c66-89b9-515c6df0aeaf.png)

![image.png](/assets/332fac6d-ec78-4931-8a64-4ba8a2ad2941.png)

3.**title:(res.data as Data<T》).msg || "网络错误"**

* res.data：接口请求返回的响应数据
* as Data<T：告诉编译器这个响应数据的数据类型
* .msg：表示从响应数据中取出错误提示文本

## 自动导入组件配置

不用import就能使用的组件

![image.png](/assets/8c6a118b-5259-4f72-a36e-6fab6aca9d62.png)

## 轮播图底部指示点变动

1.**改变触发**：这里用到了轮播图标签的一个方法，在滑动轮播图时会触发这个方法

2.**编写方法**：再这个方法中获取到轮播图的参数，然后赋值给指示点代码参数。





## 后端调取图片到轮播图

1.**首先编写一个用于接收图片的容器**：也就是一个类型，

![image.png](/assets/9def0491-a2bb-4c17-b530-f94366e8ab30.png)

2.**编写请求**：用之前封装好的http请求，

* **`distributionSite=1**：传递一个参数，用于表示要获取的哪部分轮播图，是一种前后端约定，1代表首页顶部轮播图，2代表中部广告轮播图，3代表个人中心页轮播图
* **注意要给http声明一下类型**
* **记得把上面的参数放到data中**
* 然后将

![image.png](/assets/9a60dab9-ee89-42d2-91b5-fbacf3623bfb.png)

3.**获取响应的数据**：在想要放轮播图的页面获取到这个数据

4.**声明一个数组**： 将这个数组类型也声明为banneritem

5**定义一个异步函数**：用于调用用于向后端请求的一个接口

* 同时获取到接口返回的数据
* 将这个数据封给bannerList

6.**运行函数**：这个是自动运行的所以可以调用一个什么周期函数来触发这上面的函数
