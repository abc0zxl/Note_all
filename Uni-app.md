# 注意

1.`接口请求是异步操作，需要用async/await

2.**脚本**：这里说的是script标签里的部分

3.**模板**：这里说的就是template标签部分

4.**项目bug**：同页面分类的缓存清除问题

5.**编译模式**：这个是为了方便程序员的，每次刷新的时候固定自动到某个页面并加载，不用手动过去，大大节省时间。

# Uni-app

他是一个**使用Vue.js开发**所有的前端应用框架

**简单点说他是一个依附于Vue框架的一个综合性开发框架**

**作用**：写**一套代码**，就能发布到IOS，Android,Web（响应式），以继各种小程序，等**多种平台**

**特点**：

* **90%**的代码写法和vue框架一致

# **使用方法**

1.**安装Node.js**：最好选择双数版本

2.**去Uni-app的官网**：查看创建uni-app的命令

* 项目创建流程有点像Vue
* **第一步**：直接去这个官网提示的gitee下载
* **第二步**：导入依uniapp赖包**在命令行运行npm i**
* **第一步**：或者直接在HBuilder创建，
* **第二步**：然后下载uniapp（vue3）**编译器**，**这个用于跨端运行用的**

3.**运行**：在Hbuilder中点击上面的运行，选择浏览器运行即可

* 用命令运行的话可以参考目录下的**package.json**
* 其中dev的脚步适合开发用，build适合部署上线用
* 用npm 开头再接上双引号里的内容，就行了，这里运行了dev-weixin
* 然后会生成一个dist文件，用微信小程序打开里面的mp-weixin即可

4.需要从main.js这个代码处开始运行

# 模板调用

在Hbuilder中的新建项目界面,右上角有一个**去搜索**按钮,可以搜到更多模板

# 常用调用类名词

1.**API接口**：vue给的现成工具，也可以是自己封装过的API

2.**组件**：页面的各个显示模块，功能模块，放在一个单独的component文件夹中

3.**方法**：这个是在文件中的具体的业务动作

# API接口

#### 地图导航API接口

app中的地图界面,导航等都是用了地图平台的API实现的

#### 二维码创建接口

这个是微信小程序官方的,客户扫描二维码,就可以跳转到这个小程序

# 目录结构

**这里分为多种**

* 如果仅适用于微信小程序的话结构就比较简单
* **不同的需求**：如果要实现多端适应的话结构就会复杂一些，**会多出一些文件夹**
* **不同的创建方式**：通过HbuilderX创建的就比较简易一些，用CLI命令创建的就会复杂一些
* **团队定制**：在开发过程中会更具业务扩展出一些性的文件夹，：**接口、工具、状态管理、公共组件**

1.**uni.scss**：css编译器

2.**pages.json**：**配置页面路由**的地方，导航栏，tabBar等页面类信息（启动页）。

3.**main.js**：是vue应用的**入口文件**，程序启动时的第一个执行的js文件。启动这个vue的时候，就要从它开始启动，相当于spring里的application。

* 导入核心依赖
* 配置全局选项
* 创建vue根实例
* 最终将App.vue挂载到DOM上

4.**App.vue**：负责**全局布局**和**顶层组件承载**，不处理应用的启动配置

* 负责承载全局布局
* 所以他被称为组件树的根
* 用于关联所有子组件

5.**manifest.json**：配置appid、应用名称、logo、版本等打包信息，**在用微信小程序打开时需要在里面配置AppID**

6.**index.html**：H5端页面（**H5:基于HTML5开发的网页端应用**），可以直接运行在各种浏览器中，仅在用浏览器打开时会用到。是一个容器

7.**static文件夹**：用于引用的本地静态资源的文件夹，**静态资源只能放在这里**

8.**index.vue**：是某个页面，组件的具体实现文件，是编写业务逻辑，页面，样式的核心文件。

9.**pages文件夹**：存放页面的地方，采用右键创建的方式

* 他会顺便将框架创建好
* 还会把路由添加到pages.json中

10.**.eslintrc.cjs**（警官）：他是ESLint配置文件，负责检查代码质量

11.**.perttierrc.json**（化妆师）：Prettier配置文件，负责代码排版，不管代码加没加分号，缩进是否规范，一保存就会自动帮弄成统一的样子

* 它通常和eslintrc.cjs配合，

12.**.editorconfig**（桌椅标准）：告诉vs，这个项目的基本编码格式

* 因为有的人的编辑器设置不一样，
* 这个文件就是完成**强制统一的作用**
* 例如按下tab就相当于两个空格

13.**.husky**(安检门)：一个git hooks工具，当提交代码时，Husky会拦截，并运行npm run lint-staged

* 他会强制运行上面的ESLint和Prettier,
* 如果代码格式不对他就会阻止提交代码，
* 保证上交git的代码都是对的。

14.**services**（通讯员）：用于存放”网络请求“的代码

* 就是说不要把用户和后端交互的代码放到**页面（.vue）**里面，应该单独放到一个统一的地方（**services**）
* 作用就是提高相同代码的重用性，

15.**stores**（大仓库）：作用是**状态管理**，用于存放全局共享的数据

* 登录注册的token
* 购物车的商品列表
* **这些数据都是每个页面都要用的，放到这个地方每个页面都能读取和修改**

16.**types**(字典)：用于存放TypeScript的类型定义，定义了**实体类信息**，用于代码提示，在使用某个类**如商品**，就会提示它的属性是什么，防止写错

17.**styles**(装修队）：用于存放公共的css/scss样式文件，比如专门修改时字体的文件。fonts.scss

18.**uni.scss**(uni特供的变量)：这里定义scss变量

19.**env.d.ts**（TS翻译官）：TS默认只认识.ts文件，别的文件格式需要给他声明一下，如png，.vue

20.**pnpm-lock.yaml**（货物清单）：依赖包和版本锁定的文件

* 确保在自己电脑上跑的项目，到别的地方他的配置也是相同的也能跑

21.**composables**：组合式函数，是封装各种方法的对方

## 语法规则

#### 属性绑定

1.**原来是**：src="{url}"

2.**现在是**：src="url"

#### 事件绑定

1.**升级**：直接用@提示即可

![image.png](/assets/0ea3a019-6903-43c7-bda3-5a5668efa99a.png)

#### 支持vue常用指令

* vue3支持vue2的**选项式的语法**
* uniapp也支持vue的**常用语法**

#### VSCode插件

1.**支持Ts检错**

2.**插件支持快捷生成框架**：uni-create-view

3.**快速生成uni代码提示**：uni-helper,下方的那个

4.**便捷查标签文档**：	uuniapp小程序扩展

5.**ts类型校验**：命令行安装类型声明文件，如下图所示

6.**配置tsconfig.json**：这个有模板，把types中三个个绿的移过来即可，如下图所示

![image.png](/assets/f25738d0-f066-4990-99d2-d07f3247f6b5.png)

7.**json注释报错问题**：

* 设置里
* 文件管关联：
* 添加注释报错的文件放进去。

![image.png](/assets/d804112a-2f71-4a8c-806a-bade3ee230c0.png)

## uni-ui

他的作用是自动导入组件库

**实现步骤**：

1.**导入uni-ui**：npm i @dcloudio/uni-ui

2.**配置easycom**：在pages.json中导入依赖

![image.png](/assets/fe8e703f-d62c-4937-9cad-9a1d45a59cce.png)

3.**鼠标悬停提示效果**：

* 在上面鼠标悬停显示的似乎undefine，不识别
* **实现步骤**
* **第一步**：npm i -D @uni-helper/uni-ui-types

# Pinia持久化

**作用**：他是官方提供的一个用于

* 共享数据
* 集中管理
* 更新项目中的多个组件
* 组件之间只能单向传递，解决了多组件传递数据的难题

### **使用步骤**

1.**导入pinia**：

2.**创建pinia实例**：

3.**使用pinia持久化插件**：

4.**导出pinia**：

![image.png](/assets/6cea3335-a104-4f8d-ae00-c301b8f61cbd.png)

5.**导入实例**：因为后续要使用的依赖都必须在main.ts说明一下，这样后面的程序才能用到。

6.**启用pinia**：

![image.png](/assets/e30ad7e6-e9e0-4735-832b-4b2a2a93a3ea.png)

7.**使用pinia**：

* 将这个会员信息持久化到本地
* 这里的持久化方法要改一下，因为**网页端适配**，和**小程序适配**的表示方法不一样
* ![image.png](/assets/009aeca2-c65c-4494-8db5-28882c6b6547.png)
* ![image.png](/assets/72e11bdf-7aa9-44f3-b45f-a8d103e65aa3.png)

8.**查看持久化的信息**

* 微信小程序的**调试器**中， 的storage中

# 拦截器

## 拦截request请求

**作用**：

* 拼接请求头
* 设置超时事件
* 添加小程序的请求头表示
* 添加token的请求头标识

### 实现步骤

1.添加拦截器

2.添加触发器：拦截前触发

![image.png](/assets/33fd75b4-0e90-4688-8464-148a06b3bfc1.png)

### 拼接请求头

因为地址的头一个部分会被放到一个地方，有利于修改，所以在请求发出去前，请求会被拦截把他的地址补全

![image.png](/assets/ffcd22fe-4d4a-408e-afd4-dcbd3c739fb9.png)

### 设置超时时间

![image.png](/assets/f643e2e0-1c2f-4677-8d63-1daf2731939c.png)

### 添加小程序的请求头标识

* 第一句表示直接调用原来的header，如果不存在的话，就拼接第二句。

![image.png](/assets/6f13d311-789b-4b7b-900f-b10d61365b00.png)

### 添加token的请求头标识

![image.png](/assets/2cf9be05-c72c-40f7-8cfc-737d4deff226.png)

### 将拦截器添进去

* 表示发送request，发送uploadFile都启用这个拦截器

![image.png](/assets/55e3c83e-ca89-4533-b851-7b1f37479395.png)

## 请求函数的封装

为了更加便捷的发送请求，为其设置请求成功和请求失败的逻辑，

* 自动提取返回值
* 请求失败的妥善处理，返回失败原因

### 提取成功的情况下返回的核心数据

**实现步骤**：

1.**制作框架**：一个用于发送请求的框架

![image.png](/assets/2f08dd36-bca5-435a-a617-242e2a929101.png)

2.**编写返回响应的结果**

* 这里用的Promise对象
* 设置了一个回调函数

3.当request成功时就会调用resolve返回**主体数据**

4.**泛型**：这里还要注意返回结果类型的问题。返回的response中，只有result的类型是不固定的。可以利用泛型触底类型来定义返回出去的result类型

5.**异步等待**：由于这个是在利用外部工具类实现的请求，所以要加上，同步，异步

* 在获取响应数据的地方**等待**
* 在方法外部用**异步**

![image.png](/assets/e4610741-da16-4330-89d2-aeb5da2a6e01.png)

![image.png](/assets/8f673070-8202-4f7d-9356-340a03b0ea03.png)

#### 注意

1.**这里说的请求成功**：是指这个请求成功发出去了，**收到了响应的成功**，并不是成功获取到数据的成功

* 未携带token，这个时候可以收到响应，但是，不是常说的成功的请求。
* 等等……
* 只有状态码为200的才叫获取成功
* 所以要将这些请求分离出去，按照失败来处理
* file一般是说**没有网络**

#### 升级的请求函数封装

1.**沿用axios判断规则**：状态码200~299表示成功，成功才调用resolve

![image.png](/assets/64fb4d7a-4e78-4223-a3ea-bf6e64e29960.png)

![image.png](/assets/99644feb-7444-41ba-bbc1-70e3b0b9e63d.png)

#### 返回提示信息

![image.png](/assets/629a8e6b-8e8d-46b8-b4c9-69f8eca75aa4.png)1.**uni.showToast()**：这个是uni-app提供的跨端API，作用是再页面上弹出一个轻量级的提示框

2.**icon：’none‘**：指定提示框的图标样式为”无图标“，可以是**success**,**loading**

![image.png](/assets/978b037a-677e-4c66-89b9-515c6df0aeaf.png)

![image.png](/assets/332fac6d-ec78-4931-8a64-4ba8a2ad2941.png)

3.**title:(res.data as Data<T》).msg || "网络错误"**

* res.data：接口请求返回的响应数据
* as Data<T：告诉编译器这个响应数据的数据类型
* .msg：表示从响应数据中取出错误提示文本

## 自动导入组件配置

不用import就能使用的组件

![image.png](/assets/8c6a118b-5259-4f72-a36e-6fab6aca9d62.png)

## 轮播图底部指示点变动

1.**改变触发**：这里用到了轮播图标签的一个方法，在滑动轮播图时会触发这个方法

2.**编写方法**：再这个方法中获取到轮播图的参数，然后赋值给指示点代码参数。

## 后端调取图片到轮播图

1.**首先编写一个用于接收图片的容器**：也就是一个类型，

![image.png](/assets/9def0491-a2bb-4c17-b530-f94366e8ab30.png)

2.**编写请求**：用之前封装好的http请求，

* **`distributionSite=1**：传递一个参数，用于表示要获取的哪部分轮播图，是一种前后端约定，1代表首页顶部轮播图，2代表中部广告轮播图，3代表个人中心页轮播图
* **注意要给http声明一下类型**
* **记得把上面的参数放到data中**
* 然后将

![image.png](/assets/9a60dab9-ee89-42d2-91b5-fbacf3623bfb.png)

3.**获取响应的数据**：在想要放轮播图的页面获取到这个数据

4.**声明一个数组**： 将这个数组类型也声明为banneritem

5**定义一个异步函数**：用于调用用于向后端请求的一个接口

* 同时获取到接口返回的数据
* 将这个数据封给bannerList

6.**运行函数**：这个是自动运行的所以可以调用一个**生命周期**函数来触发这上面的函数

* **onLoad**：当页面首次加载完就会触发这个函数

![image.png](/assets/1253765f-b94c-4ca3-962b-3dde81463525.png)

7.**将这个获取到的bannerList传递给轮播图**

![image.png](/assets/2edf2ad3-552a-45f9-a559-2d789ebf2ee0.png)

### 接收外部参数API

Vue3提供了一个组件，用于接收外部属性，叫**defineProps**

1.**接收参数**：接收参数就是用的这个defineProps接收，必须要用这个字母

2.**声明类型**：这里用泛型来接收，<>就是给他声明类型用的，是一个list，然后是一个banneritem的list

![image.png](/assets/b3ad6e34-ae99-4c44-a259-80235b352df3.png)

3.**调用参数**：上面最终将数据传递给了props，所以要用props.list获取

4.**最后一步将数据放到轮播图中**：在最外层swiper标签中用v-for=”……，

* 注意还要声明一下key，key是保持稳定的关键，后台识别图片是否是新加的时候起关键作用

## TypeScript中：的作用

1.**变量，常量的类型注解**

2.**函数返回值类型注解**

3.**箭头函数的返回值类型**：

4.**起别名的作用**

![image.png](/assets/6eaef540-bade-4236-9241-c8a69da5fe45.png)

## ref响应式的作用

他是响应式体系里的核心工具，

1.**ref本质是创建了一个，“包装式”的响应式数据容器**

#### 响应式

1.**动态性**：数据变了，页面能跟着自动更新，下面是他解决的问题

* **动态更新**：普通的变量变了，在另一个地方他不会变
* **变量监控**：vue无法监控普通变量的变化，

2.**智能快递盒子**：放在里面的普通变量，这个变量以改变，别的地方就能立马知道

3.**调取数据**：

* **普通变量**：就是说是模板中的变量，这个能直接用变量名**创建响应式**

![image.png](/assets/f3371dd5-6523-4062-af01-d390b5d4ab39.png)

* **在脚本中修改数据**：因为他是被ref包装过了的，**真实的子组件实例都包裹在.value属性里面**，这里就必须要用.value

![image.png](/assets/c8d6fc5c-64d7-4bd5-9a36-23d9a9db38e5.png)

### 可选链

**关键字**：**?.**作用是安全的访问嵌套的属性和方法

**作用**：当.value没有获取到的组件时，为了**不让他抛出异常**，会将返回值设置为**undefined**

### 非空断言

有时用？.也会报错，因为**他也不允许是undefined类型**，

**作用**：直接断言**非空**，非undefined

### 组件实例类型定义

2.这个定义在类型组件中，方便调用

export type AAA=InstanceType<typeof XtxGuess》

### 暴露方法或组件

1.**之前在文件中集中暴露的是API接口**：用export就能暴露

2.**单独在某个页面中暴露方法**：这里就要用到一个**暴露方法**，**defineExport**

![image.png](/assets/a8b0cb9b-040e-47b5-ab97-651f0345053f.png)

### 插值模板语法

![image.png](/assets/0bbab54c-d8a1-40e2-afe4-68be8e431f88.png)

### 动态超链接

![image.png](/assets/cc998c62-79e8-4f86-9f0a-82373aed6abf.png)

1.**：**是属性绑定符号

2.**``**：是ES6模板字符串写法,

* **他的作用是实现在静态文本内用${}插值,且{}内的值可以动态变化**

### 配置动态跳转API

用于跳转不同的样式的**页面**，

1.**独立封装一个请求API**：

* 可以传递目标url

![image.png](/assets/765194d3-a134-4486-91e2-e33f8c9d8c8d.png)

* 可以设定该页的标题id
* 可以设定该页的滚动页面参数

2.**发出这个请求就能获得这个页面参数**

### 点击事件

1.**普通点击事件**：@click

* 移动端有延迟
* 不会触发穿透

2.**小程序专用点击事件**：@tap

* 无延迟
* 可能会触发穿透

3.**@tap编写多个触发**：

![image.png](/assets/01f99c69-3c1e-447d-86e7-02f89a306b05.png)

### ：class对象语法

![image.png](/assets/f4901654-3bc6-4418-80ef-5e275e863631.png)

1.**这个{active:index===0}**：是一个对象

2.**active**：是一个类名

3.**index===0**：是一个判断语句

* 他的作用是是否要添加这个类名active

### 交叉类型

用于补齐请求参数对象中的某个元素

![image.png](/assets/be7b78cc-a0c3-4d42-8d7b-c144a0e5495f.png)

### 类型简易封装

也是和实例类型封装一样，将复杂难看的参数放到旁边，封装到一个单词的类型中

![image.png](/assets/6a084924-a961-4fbe-a225-4a1231c6ea67.png)

#### 传入复杂实例类型

1.可以一个一个内部类型放进去，然后用一个{}框起来表示原来这个位置的实力类型参数

![image.png](/assets/6aedf89c-2ba6-40a7-b909-1b150ec4db63.png)

### 计算函数

* 智能缓存管理
* 变换分类自动清理缓存

**作用**：当多个分类用的是同一个子类容器时，

1.**每次换分类需要显示对应分类的内容**

2.**这就要用到了计算函数**：computed

![image.png](/assets/b3ec5a62-4486-49a7-b44b-d243a07ec339.png)

### 代码安全

获取子对象时要注意是否为空，不然ts会报错

![image.png](/assets/85a36687-4c33-4910-91a1-0c619aeddf73.png)


### 组合式函数编写实例

将一些公共的

* 事件
* 函数

**封装到一个地方**

![image.png](/assets/f8a156eb-064a-46d9-959d-01a915c58af9.png)

**获取数据**

![image.png](/assets/2a75f54e-7020-4759-933c-80cb24c4e229.png)
