# 注意

1.`接口请求是异步操作，需要用async/await

2.**脚本**：这里说的是script标签里的部分

3.**模板**：这里说的就是template标签部分

4.**项目bug**：同页面分类的缓存清除问题

5.**编译模式**：这个是为了方便程序员的，每次刷新的时候固定自动到某个页面并加载，不用手动过去，大大节省时间。

6.**数据绑定符号{{ }}**：是放在标签之间的不是内部

7.**在标签内绑定数据**：在vue3要在前面加：绑定

8.**类型保存**：在等号=，左边不能出现**不确定类型的值**

9.。****TabBar页中的页pages中也得有路径****

# Uni-app

他是一个**使用Vue.js开发**所有的前端应用框架

**简单点说他是一个依附于Vue框架的一个综合性开发框架**

**作用**：写**一套代码**，就能发布到IOS，Android,Web（响应式），以继各种小程序，等**多种平台**

**特点**：

* **90%**的代码写法和vue框架一致

# **使用方法**

1.**安装Node.js**：最好选择双数版本

2.**去Uni-app的官网**：查看创建uni-app的命令

* 项目创建流程有点像Vue
* **第一步**：直接去这个官网提示的gitee下载
* **第二步**：导入依uniapp赖包**在命令行运行npm i**
* **第一步**：或者直接在HBuilder创建，
* **第二步**：然后下载uniapp（vue3）**编译器**，**这个用于跨端运行用的**

3.**运行**：在Hbuilder中点击上面的运行，选择浏览器运行即可

* 用命令运行的话可以参考目录下的**package.json**
* 其中dev的脚步适合开发用，build适合部署上线用
* 用npm 开头再接上双引号里的内容，就行了，这里运行了dev-weixin
* 然后会生成一个dist文件，用微信小程序打开里面dist/dev/的mp-weixin即可

4.需要从main.js这个代码处开始运行

# 模板调用

在Hbuilder中的新建项目界面,右上角有一个**去搜索**按钮,可以搜到更多模板

# 常用调用类名词

1.**API接口**：vue给的现成工具，也可以是自己封装过的API

2.**组件**：页面的各个显示模块，功能模块，放在一个单独的component文件夹中

3.**方法**：这个是在文件中的具体的业务动作

# API接口

#### 地图导航API接口

app中的地图界面,导航等都是用了地图平台的API实现的

#### 二维码创建接口

这个是微信小程序官方的,客户扫描二维码,就可以跳转到这个小程序

# 目录结构

**这里分为多种**

* 如果仅适用于微信小程序的话结构就比较简单
* **不同的需求**：如果要实现多端适应的话结构就会复杂一些，**会多出一些文件夹**
* **不同的创建方式**：通过HbuilderX创建的就比较简易一些，用CLI命令创建的就会复杂一些
* **团队定制**：在开发过程中会更具业务扩展出一些性的文件夹，：**接口、工具、状态管理、公共组件**

1.**uni.scss**：css编译器

2.**pages.json**：**配置页面路由**的地方，导航栏，tabBar等页面类信息（启动页）。

3.**main.js**：是vue应用的**入口文件**，程序启动时的第一个执行的js文件。启动这个vue的时候，就要从它开始启动，相当于spring里的application。

* 导入核心依赖
* 配置全局选项
* 创建vue根实例
* 最终将App.vue挂载到DOM上

4.**App.vue**：负责**全局布局**和**顶层组件承载**，不处理应用的启动配置

* 负责承载全局布局
* 所以他被称为组件树的根
* 用于关联所有子组件

5.**manifest.json**：配置appid、应用名称、logo、版本等打包信息，**在用微信小程序打开时需要在里面配置AppID**

6.**index.html**：H5端页面（**H5:基于HTML5开发的网页端应用**），可以直接运行在各种浏览器中，仅在用浏览器打开时会用到。是一个容器

7.**static文件夹**：用于引用的本地静态资源的文件夹，**静态资源只能放在这里**

8.**index.vue**：是某个页面，组件的具体实现文件，是编写业务逻辑，页面，样式的核心文件。

9.**pages文件夹**：存放页面的地方，采用右键创建的方式

* 他会顺便将框架创建好
* 还会把路由添加到pages.json中

10.**.eslintrc.cjs**（警官）：他是ESLint配置文件，负责检查代码质量

11.**.perttierrc.json**（化妆师）：Prettier配置文件，负责代码排版，不管代码加没加分号，缩进是否规范，一保存就会自动帮弄成统一的样子

* 它通常和eslintrc.cjs配合，

12.**.editorconfig**（桌椅标准）：告诉vs，这个项目的基本编码格式

* 因为有的人的编辑器设置不一样，
* 这个文件就是完成**强制统一的作用**
* 例如按下tab就相当于两个空格

13.**.husky**(安检门)：一个git hooks工具，当提交代码时，Husky会拦截，并运行npm run lint-staged

* 他会强制运行上面的ESLint和Prettier,
* 如果代码格式不对他就会阻止提交代码，
* 保证上交git的代码都是对的。

14.**services**（通讯员）：用于存放”网络请求“的代码

* 就是说不要把用户和后端交互的代码放到**页面（.vue）**里面，应该单独放到一个统一的地方（**services**）
* 作用就是提高相同代码的重用性，

15.**stores**（大仓库）：作用是**状态管理**，用于存放全局共享的数据

* 登录注册的token
* 购物车的商品列表
* **这些数据都是每个页面都要用的，放到这个地方每个页面都能读取和修改**

16.**types**(字典)：用于存放TypeScript的类型定义，定义了**实体类信息**，用于代码提示，在使用某个类**如商品**，就会提示它的属性是什么，防止写错

17.**styles**(装修队）：用于存放公共的css/scss样式文件，比如专门修改时字体的文件。fonts.scss

18.**uni.scss**(uni特供的变量)：这里定义scss变量

19.**env.d.ts**（TS翻译官）：TS默认只认识.ts文件，别的文件格式需要给他声明一下，如png，.vue

20.**pnpm-lock.yaml**（货物清单）：依赖包和版本锁定的文件

* 确保在自己电脑上跑的项目，到别的地方他的配置也是相同的也能跑

21.**composables**：组合式函数，是封装各种方法的对方

## 语法规则

#### 属性绑定

1.**原来是**：src="{url}"

2.**现在是**：src="url"

#### 事件绑定

1.**升级**：直接用@提示即可

![image.png](/assets/0ea3a019-6903-43c7-bda3-5a5668efa99a.png)

#### 支持vue常用指令

* vue3支持vue2的**选项式的语法**
* uniapp也支持vue的**常用语法**

#### VSCode插件

1.**支持Ts检错**

2.**插件支持快捷生成框架**：uni-create-view

3.**快速生成uni代码提示**：uni-helper,下方的那个

4.**便捷查标签文档**：	uuniapp小程序扩展

5.**ts类型校验**：命令行安装类型声明文件，如下图所示

6.**配置tsconfig.json**：这个有模板，把types中三个个绿的移过来即可，如下图所示

![image.png](/assets/f25738d0-f066-4990-99d2-d07f3247f6b5.png)

7.**json注释报错问题**：

* 设置里
* 文件管关联：
* 添加注释报错的文件放进去。

![image.png](/assets/d804112a-2f71-4a8c-806a-bade3ee230c0.png)

## uni-ui

他的作用是自动导入组件库

**实现步骤**：

1.**导入uni-ui**：npm i @dcloudio/uni-ui

2.**配置easycom**：在pages.json中导入依赖

![image.png](/assets/fe8e703f-d62c-4937-9cad-9a1d45a59cce.png)

3.**鼠标悬停提示效果**：

* 在上面鼠标悬停显示的似乎undefine，不识别
* **实现步骤**
* **第一步**：npm i -D @uni-helper/uni-ui-types

# Pinia持久化

**作用**：他是官方提供的一个用于

* 共享数据
* 集中管理
* 更新项目中的多个组件
* 组件之间只能单向传递，解决了多组件传递数据的难题

### **使用步骤**

1.**导入pinia**：

2.**创建pinia实例**：

3.**使用pinia持久化插件**：

4.**导出pinia**：

![image.png](/assets/6cea3335-a104-4f8d-ae00-c301b8f61cbd.png)

5.**导入实例**：因为后续要使用的依赖都必须在main.ts说明一下，这样后面的程序才能用到。

6.**启用pinia**：

![image.png](/assets/e30ad7e6-e9e0-4735-832b-4b2a2a93a3ea.png)

7.**使用pinia**：

* 将这个会员信息持久化到本地
* 这里的持久化方法要改一下，因为**网页端适配**，和**小程序适配**的表示方法不一样
* ![image.png](/assets/009aeca2-c65c-4494-8db5-28882c6b6547.png)
* ![image.png](/assets/72e11bdf-7aa9-44f3-b45f-a8d103e65aa3.png)

8.**查看持久化的信息**

* 微信小程序的**调试器**中， 的storage中

# 拦截器

## 拦截request请求

**作用**：

* 拼接请求头
* 设置超时事件
* 添加小程序的请求头表示
* 添加token的请求头标识

### 实现步骤

1.添加拦截器

2.添加触发器：拦截前触发

![image.png](/assets/33fd75b4-0e90-4688-8464-148a06b3bfc1.png)

### 拼接请求头

因为地址的头一个部分会被放到一个地方，有利于修改，所以在请求发出去前，请求会被拦截把他的地址补全

![image.png](/assets/ffcd22fe-4d4a-408e-afd4-dcbd3c739fb9.png)

### 设置超时时间

![image.png](/assets/f643e2e0-1c2f-4677-8d63-1daf2731939c.png)

### 添加小程序的请求头标识

* 第一句表示直接调用原来的header，如果不存在的话，就拼接第二句。

![image.png](/assets/6f13d311-789b-4b7b-900f-b10d61365b00.png)

### 添加token的请求头标识

![image.png](/assets/2cf9be05-c72c-40f7-8cfc-737d4deff226.png)

### 将拦截器添进去

* 表示发送request，发送uploadFile都启用这个拦截器

![image.png](/assets/55e3c83e-ca89-4533-b851-7b1f37479395.png)

## 请求函数的封装

为了更加便捷的发送请求，为其设置请求成功和请求失败的逻辑，

* 自动提取返回值
* 请求失败的妥善处理，返回失败原因

### 提取成功的情况下返回的核心数据

**实现步骤**：

1.**制作框架**：一个用于发送请求的框架

![image.png](/assets/2f08dd36-bca5-435a-a617-242e2a929101.png)

2.**编写返回响应的结果**

* 这里用的Promise对象
* 设置了一个回调函数

3.当request成功时就会调用resolve返回**主体数据**

4.**泛型**：这里还要注意返回结果类型的问题。返回的response中，只有result的类型是不固定的。可以利用泛型触底类型来定义返回出去的result类型

5.**异步等待**：由于这个是在利用外部工具类实现的请求，所以要加上，同步，异步

* 在获取响应数据的地方**等待**
* 在方法外部用**异步**

![image.png](/assets/e4610741-da16-4330-89d2-aeb5da2a6e01.png)

![image.png](/assets/8f673070-8202-4f7d-9356-340a03b0ea03.png)

#### 注意

1.**这里说的请求成功**：是指这个请求成功发出去了，**收到了响应的成功**，并不是成功获取到数据的成功

* 未携带token，这个时候可以收到响应，但是，不是常说的成功的请求。
* 等等……
* 只有状态码为200的才叫获取成功
* 所以要将这些请求分离出去，按照失败来处理
* file一般是说**没有网络**

#### 升级的请求函数封装

1.**沿用axios判断规则**：状态码200~299表示成功，成功才调用resolve

![image.png](/assets/64fb4d7a-4e78-4223-a3ea-bf6e64e29960.png)

![image.png](/assets/99644feb-7444-41ba-bbc1-70e3b0b9e63d.png)

#### 返回提示信息

![image.png](/assets/629a8e6b-8e8d-46b8-b4c9-69f8eca75aa4.png)1.**uni.showToast()**：这个是uni-app提供的跨端API，作用是再页面上弹出一个轻量级的提示框

2.**icon：’none‘**：指定提示框的图标样式为”无图标“，可以是**success**,**loading**

![image.png](/assets/978b037a-677e-4c66-89b9-515c6df0aeaf.png)

![image.png](/assets/332fac6d-ec78-4931-8a64-4ba8a2ad2941.png)

3.**title:(res.data as Data<T》).msg || "网络错误"**

* res.data：接口请求返回的响应数据
* as Data<T：告诉编译器这个响应数据的数据类型
* .msg：表示从响应数据中取出错误提示文本

## 自动导入组件配置

不用import就能使用的组件

![image.png](/assets/8c6a118b-5259-4f72-a36e-6fab6aca9d62.png)

## 轮播图底部指示点变动

1.**改变触发**：这里用到了轮播图标签的一个方法，在滑动轮播图时会触发这个方法

2.**编写方法**：再这个方法中获取到轮播图的参数，然后赋值给指示点代码参数。

## 后端调取图片到轮播图

1.**首先编写一个用于接收图片的容器**：也就是一个类型，

![image.png](/assets/9def0491-a2bb-4c17-b530-f94366e8ab30.png)

2.**编写请求**：用之前封装好的http请求，

* **`distributionSite=1**：传递一个参数，用于表示要获取的哪部分轮播图，是一种前后端约定，1代表首页顶部轮播图，2代表中部广告轮播图，3代表个人中心页轮播图
* **注意要给http声明一下类型**
* **记得把上面的参数放到data中**
* 然后将

![image.png](/assets/9a60dab9-ee89-42d2-91b5-fbacf3623bfb.png)

3.**获取响应的数据**：在想要放轮播图的页面获取到这个数据

4.**声明一个数组**： 将这个数组类型也声明为banneritem

5**定义一个异步函数**：用于调用用于向后端请求的一个接口

* 同时获取到接口返回的数据
* 将这个数据封给bannerList

6.**运行函数**：这个是自动运行的所以可以调用一个**生命周期**函数来触发这上面的函数

* **onLoad**：当页面首次加载完就会触发这个函数

![image.png](/assets/1253765f-b94c-4ca3-962b-3dde81463525.png)

7.**将这个获取到的bannerList传递给轮播图**

![image.png](/assets/2edf2ad3-552a-45f9-a559-2d789ebf2ee0.png)

### 接收外部参数API

Vue3提供了一个组件，用于接收外部属性，叫**defineProps**

1.**接收参数**：接收参数就是用的这个defineProps接收，必须要用这个字母

2.**声明类型**：这里用泛型来接收，<>就是给他声明类型用的，是一个list，然后是一个banneritem的list

![image.png](/assets/b3ad6e34-ae99-4c44-a259-80235b352df3.png)

3.**调用参数**：上面最终将数据传递给了props，所以要用props.list获取

4.**最后一步将数据放到轮播图中**：在最外层swiper标签中用v-for=”……，

* 注意还要声明一下key，key是保持稳定的关键，后台识别图片是否是新加的时候起关键作用

## TypeScript中：的作用

1.**变量，常量的类型注解**

2.**函数返回值类型注解**

3.**箭头函数的返回值类型**：

4.**起别名的作用**

![image.png](/assets/6eaef540-bade-4236-9241-c8a69da5fe45.png)

## ref响应式的作用

他是响应式体系里的核心工具，

1.**ref本质是创建了一个，“包装式”的响应式数据容器**

#### 响应式

1.**动态性**：数据变了，页面能跟着自动更新，下面是他解决的问题

* **动态更新**：普通的变量变了，在另一个地方他不会变
* **变量监控**：vue无法监控普通变量的变化，

2.**智能快递盒子**：放在里面的普通变量，这个变量以改变，别的地方就能立马知道

3.**调取数据**：

* **普通变量**：就是说是模板中的变量，这个能直接用变量名**创建响应式**

![image.png](/assets/f3371dd5-6523-4062-af01-d390b5d4ab39.png)

* **在脚本中修改数据**：因为他是被ref包装过了的，**真实的子组件实例都包裹在.value属性里面**，这里就必须要用.value

![image.png](/assets/c8d6fc5c-64d7-4bd5-9a36-23d9a9db38e5.png)

### 可选链

**关键字**：**?.**作用是安全的访问嵌套的属性和方法

**作用**：当.value没有获取到的组件时，为了**不让他抛出异常**，会将返回值设置为**undefined**

### 非空断言

有时用？.也会报错，因为**他也不允许是undefined类型**，

**作用**：直接断言**非空**，非undefined

### 组件实例类型定义

2.这个定义在类型组件中，方便调用

export type AAA=InstanceType<typeof XtxGuess》

### 暴露方法或组件

1.**之前在文件中集中暴露的是API接口**：用export就能暴露

2.**单独在某个页面中暴露方法**：这里就要用到一个**暴露方法**，**defineExport**

![image.png](/assets/a8b0cb9b-040e-47b5-ab97-651f0345053f.png)

### 插值模板语法

![image.png](/assets/0bbab54c-d8a1-40e2-afe4-68be8e431f88.png)

### 动态超链接

![image.png](/assets/cc998c62-79e8-4f86-9f0a-82373aed6abf.png)

1.**：**是属性绑定符号

2.**``**：是ES6模板字符串写法,

* **他的作用是实现在静态文本内用${}插值,且{}内的值可以动态变化**

### 配置动态跳转API

用于跳转不同的样式的**页面**，

1.**独立封装一个请求API**：

* 可以传递目标url

![image.png](/assets/765194d3-a134-4486-91e2-e33f8c9d8c8d.png)

* 可以设定该页的标题id
* 可以设定该页的滚动页面参数

2.**发出这个请求就能获得这个页面参数**

### 点击事件

1.**普通点击事件**：@click

* 移动端有延迟
* 不会触发穿透

2.**小程序专用点击事件**：@tap

* 无延迟
* 可能会触发穿透

3.**@tap编写多个触发**：

![image.png](/assets/01f99c69-3c1e-447d-86e7-02f89a306b05.png)

### ：class对象语法

![image.png](/assets/f4901654-3bc6-4418-80ef-5e275e863631.png)

1.**这个{active:index===0}**：是一个对象

2.**active**：是一个类名

3.**index===0**：是一个判断语句

* 他的作用是是否要添加这个类名active

### 交叉类型

用于补齐请求参数对象中的某个元素

![image.png](/assets/be7b78cc-a0c3-4d42-8d7b-c144a0e5495f.png)

### 类型简易封装

也是和实例类型封装一样，将复杂难看的参数放到旁边，封装到一个单词的类型中

![image.png](/assets/6a084924-a961-4fbe-a225-4a1231c6ea67.png)

#### 传入复杂实例类型

1.可以一个一个内部类型放进去，然后用一个{}框起来表示原来这个位置的实力类型参数

![image.png](/assets/6aedf89c-2ba6-40a7-b909-1b150ec4db63.png)

### 计算函数

* 智能缓存管理
* 变换分类自动清理缓存

**作用**：当多个分类用的是同一个子类容器时，

1.**每次换分类需要显示对应分类的内容**

2.**这就要用到了计算函数**：computed

![image.png](/assets/b3ec5a62-4486-49a7-b44b-d243a07ec339.png)

### 代码安全

获取子对象时要注意是否为空，不然ts会报错

![image.png](/assets/85a36687-4c33-4910-91a1-0c619aeddf73.png)

### 组合式函数编写实例

将一些公共的

* 事件
* 函数

1. const {这个里面既可以有触发用的方法名字，也有获取参数的函数名字} = guess（）；
2. 本质是把**需要对外暴露的 “可执行动作” 和 “可访问数据”** 都封装在返回对象里，想用哪个拆哪个。

**封装到一个地方**

![image.png](/assets/f8a156eb-064a-46d9-959d-01a915c58af9.png)

**获取数据**

![image.png](/assets/2a75f54e-7020-4759-933c-80cb24c4e229.png)

## 手机号快捷登录

这个需要用企业级的，对个人不开放

1.**定义接口**

2.获取手机号：对开发者不开放

3.**获取凭证code**

4.**封装信息请求登录**

![image.png](/assets/81faa09c-9986-494a-9bea-5eda1c1c7cb2.png)

#### 这个是测试专用接口

1.具体用法如图所示

![image.png](/assets/5efad4b2-c71b-4ead-bbd0-ddebe672d108.png)

### 分包预下载（仅限于微信小程序）

在原来的情况下将各个页面，列表分开加载，已经体现了性能优化

**升级版**：为了提高用户体验，可以将某些简单点的组件进行预加载，以此提高用户体验。

**例如**：我的页面**设置**

##### 实现步骤

1.**新建一个文件夹**：专门放预加载页面用的

2.**创建分包**：记得要用快捷键创建

* 这样会在pages.json中自动导入分包

3.**设置预下载规则**：**preloadRule**

**注意这个preloadRule和subPackages同级**

* **编写触发预下载地址**
* 网络方式：仅限于wifi，不限网络
* 分包选择：指定预下载分包，**这个可以指定文件夹**

下面表示加载成功

![image.png](/assets/3d4c4a5a-02d3-48d2-8be3-1928a91e59d4.png)

## ****对象解构赋值****

表示调用了一个方法后在其返回的对象中，只**单独获取对象中的某个元素的值**

![image.png](/assets/1466c6ed-4a38-4dd2-ad52-f76cf70740de.png)

![image.png](/assets/0eb74260-2cae-4696-a583-68ed3e64fba9.png)

## 数组解构赋值

1.会按照位置顺序将对象中的参数复制到左边的变量上

**![image.png](/assets/0316e25f-673b-4126-938f-f88134832969.png)**

2.**合并对象赋值**：将括号中右边的参数和编导左边的对象中

![image.png](/assets/59548ccc-f53d-41f9-a572-78234dc1afe3.png)

![image.png](/assets/8536711a-8174-4d11-9494-e99b22521424.png)

![image.png](/assets/d25aae64-0de5-4cb9-aa85-7a1e0c509821.png)

## result,value,detail

1.**.detail(标准事件载体)**

2.**.value(响应式变量的解析)**

3.**.result（自定义函数的数据解析）**

## String转json

![image.png](/assets/9678dbe4-3c81-490c-991f-5c9fb23024d5.png)

**因为所需的avater在字符串中不能直接提取出来**

**所以要先转换为JSON类型才能单独获取到avater**

![image.png](/assets/10afa321-5d86-44bc-b85a-27577665ab4b.png)

## JSON转String

用join（“A”）方法，这个可以直接连接json各个字符元素，join中的A表示插入的间隔字符，没有的话表示不插入

![image.png](/assets/10aec87b-f2d3-4e33-b859-8b24a607add6.png)

## 类型的简化

**问题**：定义的类型多了，但大多数类型中都有大量的相同属性

1.可以将这些相同的属性抽取出来，单独封装，然后要用的时候可以直接拼接~~~~

## 现场自定义类型

令一个变量的类型为[string,string,string]

相当于一个数组，个每个组成员定义类型

#### 交叉类型:&

#### 选取类型+交叉类型：Pick

![image.png](/assets/57085c09-5d5e-4d8f-a066-14db80faff65.png)

## 按钮类型的方法

按钮类型需要用uniHelper来指定类型RadioGroupChange。

`RadioGroupChange` 是 TS 中约束 `<radio-group>` 组件 `change` 事件参数的类型

## 日期修改

实现修改日期后能存储

1.**他是一个关键字**：piker

2.**设定一个修改触发方法**：@change

3.**在方法中修改日期**

4.**将日期提交到上传后台的方法中**

![image.png](/assets/cd5fbf3e-e29b-454f-9dfa-ce7d579d66ae.png)

## 地址修改

### 动态设置地址标题

因为有可能是修改地址，也有可能是设置地址，这两个共用同一个页面

![image.png](/assets/5d77134c-b1f0-499d-81dd-6811cd92f4af.png)

1.**可以通过前面传来的url参数**：作为依据判断是修改地址还是增加地址，

2.**获取请求参数**：可以采用获取单个参数方式获取传递过来的参数集

![image.png](/assets/df6a2743-b7e8-43f2-bbd9-98b3ec07755a.png)

## 新增地址步骤

1.**编写封装API**：用于传递新建的地址

2.**编写地址的类型声明**：

3.**获取再界面设定的参数**：要用双向绑定v-model

4.**因为picker标签上的：value**：是用于回显到，地址选择滚动器上的，所以要用json，而存储的地址，他是string，所以要转换

![image.png](/assets/a4cf1131-309d-4cf0-a76d-f1d707443629.png)

5.**picker选好后触发change传递过来的是一个json**：需要用join转换为string，存到对象中

![image.png](/assets/16cfcf67-32bd-4acc-b2ef-aaf05fd5c67f.png)

## 上传git报错没通过代码校验

1.因为代码中有报错，没通过eslint

2.**直接屏蔽eslint**

### 屏蔽单个eslint

1.**用代码提示生成//类型屏蔽语句**

### 屏蔽多个eslint

2.**在三个大标签上添加屏蔽语句**：

![image.png](/assets/24718bd5-060b-400b-bdb7-5484a4d2e198.png)

## 枚举类型

在vue中的枚举类型也是因为让某些静态值，变得可读性更强。**更有语义**

![image.png](/assets/e787e522-f521-4019-9478-d70272181fa4.png)

## 修改商品数量

1.这个需要实时上传

* 就是说要给她写一个API

2.有专门的工具来辅助

![image.png](/assets/e62cd376-4586-414e-92bf-dc258b3290dc.png)

## 计算属性的使用

1.可以计算return为true的数量

2.它是**响应式，带缓存**，只要里面的变量变了，他就就会重新计算，

![image.png](/assets/cc4a46bb-ad55-4ef5-8147-bec05543e9f7.png)

* 上面的value.every()是数组的every方法，列表中所有的成员必须满足v.selected全部为true，他才会返回true，否则就是false。
* 这个用来判断是否已经全选比较有效

3.**filter**：可以过滤出所有状态的数量

## 全选按钮点击的操作

1.取出全选按键的反色

2.将所有成源修改为这个颜色

![image.png](/assets/aad41e3a-e7ac-4906-bf28-2dee160a038a.png)

## 步进器

用于处理商品数量的修改上传

**使用步骤**

1.**导入类型声明**

2.在数量修改器标签内编写这个步进器标签

3.**配置参数等，记得绑定index的skuid**

4.注意触发函数的参数类型，他的类型去@change获得

5.然后就可以直接打印看函数参数，每次点击的时候都能修改成功，并有对应数值，和skuid

![image.png](/assets/1d29fe22-3738-4a3d-af4d-3f3cd1fe02bc.png)

## 数组方法includes

表示这个数组的某个值，知否在这个自定义的数组的范围内

![image.png](/assets/a7c89187-bc8d-4024-9ae0-fddb0862a2bc.png)

## 事件绑定+箭头函数

1.**@change**：Vue事件绑定语法糖，轮播，标签页，选择器等

2.**$event**：vue内置的**事件对象变量**，代表触发事件传递过来的**事件对象**

![image.png](/assets/0a0dafb7-97f6-44be-a2c3-036f7c1db5e7.png)

3.**detail.current**：代表当前滑动的页面数值

![image.png](/assets/46c194ff-478a-4574-bf91-6b95bf4cc2c3.png)

# 多端uniapp配置

## 网页端打包

* 网页端不支持微信平台授权登录功能
* 可以用条件变也，让代码按照条件编译到不同平台

1.**条件编译和网页端打包**：通过不同的条件，讲代码编译到不同的平台

![image.png](/assets/25d8e365-e944-4e7b-8f0d-00a79f8fb522.png)

2.**登录页的快捷登录条件编译**：网页用不了快捷登录

![image.png](/assets/74033856-4343-4736-96fc-748ec7dc464e.png)

3.**登录页输入框条件编译**：微信小程序不用账号密码输入框

![image.png](/assets/e4dd2133-ecf2-4d67-96b8-6356a4c81d6c.png)

4.**网页端不能唤起微信支付**：

![image.png](/assets/5403a211-9a7d-4c95-b717-798b1518f65d.png)

5.**更多**

* **售后**：功能在网页端也不能实现
* **路由**：这个是代码中的绝对地址不管用了，要用相对地址
* ![image.png](/assets/1323bd60-5dd4-454c-88dd-adfc5902803c.png)
* ![image.png](/assets/4ef4fd77-f1c1-4b04-b6a6-cce4d1a8ac5b.png)
* ![image.png](/assets/e469414e-41f0-4f4c-a87f-cce78d98cf3f.png)
* **相关配置**：在manifest.json中的
* ![image.png](/assets/6c8565b7-ed41-4f6b-a574-dc302d772876.png)

## Android端打包

### 本地连接电脑打包

* 用HBuilderX，利用其中的**运行到Android APP**
* Android手机

![image.png](/assets/5c2ba47b-7bb9-427f-aeb2-c1f0f5640506.png)

1.**将数据线连接到电脑**

2..**根据手机提示版本适配**：根据提示信息将编译版本升级到**指定版本**，直到适配即可

![image.png](/assets/7b56e6f3-8831-4d0f-ae82-b17227e49c7e.png)

### 手机上下载运行

1.**登录DCloud账号**：

2.**获取Dcloud APPID**：用于云打包用的ID

* 在minifest.json的文件中
* 在基础配置中
* 点击重新获取
* ![image.png](/assets/61f1b6e3-0d86-4a24-a22a-58c915af1c4b.png)

3.**在manifest中**：设置要用**名称，图标设置**

4.**发行App云打包**：点击hbuilder上面的发行中的APP云打包，****

* 使用**云端证书**：需要去DCloud中申请（点击详情），然后点击下面的DCloud开发者中心，点击项目里面的Android证书。
* **点击打包**

### IOS端打包

1.**项目导入到HBuilderX**

2.**运行到手机模拟器**

需要**苹果电脑**

3.**运行到IOS基座**

* 直接运行肯定失败，点击提示
* 下载一个模拟器
* 下载一个软件Xcode：可以自带很多模拟器
* 成功启动 模拟器查看

4.**打包具体步骤**

* 点击APP打包
* 点击申请证书，**他需要登录IOS的开发者中心，并使用开发者账号，这个每年都需要好几百**
* 申请到证书+密钥填写好就好了

# 跨端兼容

因为有些小程序，对语法有不同的要求，同一个样式，不同端就会报错和显示不一样，例如

* 小程序端不支持*选择器，非H5端不支持*选择器
* 视口差异：会影响滚动触底的功能
* ![image.png](/assets/bba24838-1997-441a-a4e5-c0dc2f711889.png)
* H5默认开启scoped

## 解决方法

1.**多端语法差异**：用view.text文件来

2.**视口差异**：在代码中声明好视口区域

H5端的tabBar高度就是最底部，会导致一些内容和组件被tabBar遮挡，

**关键字**：uniapp提供了内置的css变量：**--window -bottom,**

使用了这个变量，就会让组件正常显示，像上面最右边的图片

![image.png](/assets/3415c2b7-250f-43d2-9fcc-785df095bbdd.png)

3.**uniapp在H5开启样式隔离scoped**

因为uniapp的也买你切换是在同一个页面中替换组件达到的换页效果，

* 不隔离样式会导致样式之间冲突
* 小程序端是一个多页面应用所以不会报错
* **例子**：骨架屏它是基于原来在这个页面上的样式生成的，在H5端样式被隔离后就会显示失败
* **APP端**：他的组件样式也会**默认被隔离**

### H5端处理方法

1.将样式隔离出去，

2.**在被隔离的页面，将其单独导入即可**：这个给解决的是骨架屏的部分

![image.png](/assets/9c7709b7-8f46-4b76-bd55-a401ca5c3638.png)

3.**最好配上条件编译使用**：因为有的端他不会条件隔离

![image.png](/assets/80b5a1cf-43aa-4c5b-a995-a15ea1e64d5e.png)

### App端处理方法

* 通过HBuilder的运行到手机模拟器，点击通过Webview调试就能查看App端的错误，然后针对调试bug

1.**添加条件编译**

**问题**：缺少渲染，导致的滚动异常

**解决问题**：在对应的标签中加入缺少的内容

![image.png](/assets/efa6969a-81ae-492a-8ca2-1305fac941ce.png)

### 组件兼容

在uniapp中用到的**小程序组件**，但在某些平台中，有些支持有些不支持。所以要通过**条件编译将不支持的组件作不显示处理**

![image.png](/assets/65d161ca-e77d-4fac-a0dc-275b7c061324.png)

1.**首先去到对应页面**：写条件编译

![image.png](/assets/395bd1aa-4f58-464d-9330-336db4d7653a.png)

2.**调节变化后的样式**

* 找到不能和谐显示的原因
* 通过条件编译，加入样式代码，实现样式的调节

![image.png](/assets/3667d421-3a78-46a8-b490-b4ca5bea9f11.png)

### Js API兼容

因为某些api只支持某些平台，换了平台就不支持了，例如上传图片的API，只支持微信小程序端

![image.png](/assets/da3159cc-b5a4-4756-9786-c1f1e851d59d.png)

1.**条件编译，不同的端用不同的API**：

**小程序端**：chooseMedia

**H5端**：chooseImage

![image.png](/assets/5a5e9d1a-f16f-4401-aca5-35661b846232.png)

![image.png](/assets/69a15878-5063-4675-a02c-4e2cf075a9f8.png)

# uniCloude云开发

就是可以通过js来开发**服务端**，

* 云数据库
* 云函数
* 云存储

后期会利用到一些API，例如

* 地区选择
* 城市选择

1.**准备工作**：

* 登录uniCloud
* 新建服务空间
* 新建云数据库
* 在Hbuilder创建云开发环境
* 下载DB，云端配置
* 运行到浏览器



1.**去uniCloude开通服务空间**：阿里云有一次免费的可以用

2.**新建云数据库**：搜索要
