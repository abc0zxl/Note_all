# 缓存优化

同一个数据库表，在某些时间段内会被大量用户访问，数据库压力大，然后就会造成卡顿，用户体验非常不好。

**解决**：将访问的表下载导本地缓存。

**问题**：

* 某些时刻会遭受到大量访问
* 用户体验差
* 数据库压力大

**解决**

* 通过redis来缓存菜品数据，减少数据库的操作。
* ![image.png](/assets/6b9d01e5-dfee-4409-bae8-9f052fb8181a.png)

**任务**：

* 如何实现将菜品保存到redis
* 将哪些数据放到缓存中
* 一次放多少数据到缓存
* 遇到数据更新怎么办

## 实现案例

1.**前置准备工作**

* **导入redis坐标**
* **编写redis的配置**
* **导入Redis操作工具**

2.**编写redis的Key名命规则**

3.**获取Redis中的数据**：

* 这里要提前设置redis中取出的数据的类型，那redis数据类型中的哪一个
* 通过获取的集合是否为空来判断是否要去查数据库

4.**redis没找到的情况**：

* 首先用list获取数据
* 用redis对象的方法，将list数据放入redis中
* **通常以ID来名命他的存储空间名字**，这样下次好找

![image.png](/assets/68ad301f-9d60-4f81-9c3d-b525994b128a.png)




## Redis更新

redis的数据要和数据库的一致，不然会导致前端看到的是以前的数据。

**解决**：增删改都需要**清理redis**，哪份数受影响就清理那个

**实现步骤**

1.**存储到redis的数据，每一次都会新建一个key名称，且这个名称是通过分类id拼接的**

2.当增删改发生时，在controller后面新加一个清理缓存的操作，具体操作就是，根据得到的菜品的分类id，再次拼接出key的名称，然后删除该key的缓存

![image.png](/assets/1a0abef6-f3bb-462c-a9e5-f5887867fc17.png)

3.**如果操作过于复杂**：例如批量删除操作，此时前端只传过来了id，要知道分类id，又要重新查，而且还有相同的分类的情况。**这种情况，直接清除所有菜品分类的缓存数据**，

* 先查key
* 再删除key
* ![image.png](/assets/ed0528db-fc4b-453c-9d2b-88dd7e4dc661.png)


4.**遇到操作过于繁琐的情况**：删除影响区域的缓存就好了。




# Spring Cache

这个是spring提供的缓存框架，提供了一系列注解，在有缓存操作的地方在上面加入一个注解就可以实现缓存功能。

**可以切换缓存实现**：直接导入坐标，spring就会自动识别

* EHCache
* Caffeine
* Redis：通常情况下用这个


## 常用注解

![image.png](/assets/358a2298-1f12-4fcf-b62f-77fcce51b5c5.png)


**cacheName**：CacheName 在 Spring Cache 里的核心价值就是**对缓存 key 做业务分组管理**，相当于给不同业务的缓存建了 “专属文件夹”

### **@CachePut**

放到对应的controller方法上面，并指定cache的name

，和key。

#### 动态设定注解中的key值

1.**这里用到了spring的EL表达式**：

具体用法可以查看@CachePut注解的java文件。（加入class，然后按照提示下载文件）

* 用#开头
* 可以采用**上下绑定**的方法，用同名来操作下面的对象，并获取到对象中的值。下面是两种取法

![image.png](/assets/74fe6ba1-eebe-46af-842f-01c92c573652.png)

![image.png](/assets/32214199-97d7-4de3-98f8-04618c3e8671.png)



### @Cacheable

根据写入的攻台key查询是否有数据，如果有就调用，没有就利用这个key来创建。

![image.png](/assets/cb15452a-ccee-456f-a3f5-6b5a943797dc.png)

### @CacheEvict

* 可以根据id来删除某个key下的值
* 也可以根据CacheName删除整个chachename下的key
* ![image.png](/assets/ba48b9f5-eeee-4cbe-8466-99f6fdb2dd85.png)
