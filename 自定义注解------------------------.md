![image.png](/assets/eeddbf76-d598-4140-8465-61ab24cea28d.png)

# 自定义注解——用于校验规则

如果现有的注解无法满足要求，再别的地方编写规则很容易出现代码重写的问题，而且不好写。

这时就可以利用一个注解来声明，像别的校验注解一样实现校验功能。

这就需要我们自己编写这个注解了，实现校验的功能。

## 实现步骤

### **编写前置注解**：

用于准备工作，例如告知这个注解使用规则

* 编写位置：@Target
* 加入到文档中去，启用：@Documented
* 声明校验类：@Constraint(validatedBy={这个就是下面编写的校验类})

@Documented

**作用**：讲标注了这个注解的**自定义注解类**，这个自定义注解会被java文档生成工具收录到API文档中。

**位置**：自定义注解的类上面，专用**元注解**

@Target

**作用**：表示i这个自定义注解将来可以放到说明上面生效，**类上**，**属性**

@Retention

**作用**：表示这个自定义注解将来运行时，在那些阶段会被保留。（运行时，），注意这个位置字段的依赖不好弄，看截图就好

![image.png](/assets/5a720b31-4cd1-4363-ba60-13d8996b32b2.png)

@Constraint（validatedBy={AAA.class}）

**作用**：表示谁来提供这个注解的校验规则，这里是注解拦截校验规则的关键

### **编写内部方法信息**：

这个按照上面图片的模板来就行，或者随便进入一个校验注解代码中赋值。

1.**提示信息**：用于校验失败后的提示信息

* message

2.**指定分组**：是指校验规则的分组

* groups

3.**负载**：可以获取到这个注解的附加信息

* payload

### 测试结果

校验信息在message的最后一行

![image.png](/assets/98a4ff90-4ddb-4b5a-bb10-d23557640306.png)

# 

# 编写校验规则类

**实现步骤**

1.**创建一个新的文件夹**：然后再它下面创建校验类

2.**实现接口**：ConstrainValidator<A,B

* 注意这个A，B的位置是实现的接口旁边
* ![image.png](/assets/96ec7ca1-8402-4dd8-9a4d-f3bee10e628c.png)
* A:给那个注解提供
* B:校验的数据类型，一般是String

3.**实现方法**：isValidation(value,context)用于提供校验规则

* Value：将来要校验的数据，
* context

4.**编写方法内容**：这里就是校验value字符串的，是这个用于校验的注解的核心。

* value为空就return false
* value值为AAA，就return true

5.**编写完成**
