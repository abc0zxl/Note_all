## 更新普通信息

更新信息传递的是一个对象的时候。

用户的Id获取还是通过**拦截器**和**本地线程传递参数**

**获取id**

* 一种是获取username，再调用service方法得到user对象，然后获取id
* 直接用map接住解码后的数据，然后再通过他的username和service获取user对象
* ![image.png](/assets/96eca944-cd3a-4089-8bba-cd29e967cc29.png)
* ![image.png](/assets/cbb6cf53-847f-44fd-a2b4-4692cdbc1e8a.png)

#### 实体参数的校验

当传递的参数是一个对象时，就不能用原来在参数旁边的validation方法了，可以利用尸体参数校验的方法。

@NotNUull：表示这个参数不能为空

@NotEmpty：表示这个参数，以及string类不能为null

@Email：这个是邮箱的专属注解，也有非空的意思。

@Pattern:(regexp=""):这个是validation的方

#### postman

由于来回传递对象用的是json，而且是修改信息

**参数位置**：

1.所以参数信息应该放在json中，而不是header

![image.png](/assets/88fb67b2-a8e8-4227-bf56-41c9821133c4.png)

## 设置更新时间

有两种方式

1.**mysql提供的**：在sql语句上编写

![image.png](/assets/d293cc2b-cf3d-4205-9139-59961699f0aa.png)

2.**在controller生成时间**：

![image.png](/assets/f62c6042-f66f-4fdf-b912-cd7de2f37ce4.png)

## 更新密码

修改用户的普通数据入，昵称，邮箱，等这些权限不高，但是修改密码是一个敏感的操作，所以要单独设置一个地方修改密码。

**功能设置**：

* 原密码
* 新密码
* 确认密码

1.**编写注解**：@PatchMapping()

2.**编写参数**：他的参数通过map来**存储**，**获取**，注意加@RequestBody转化注解

3.**编写逻辑**：

* 缺少参数
* 原密码比对：service->用户密码（加密）->加密原密码->比对

  ![image.png](/assets/b56a3bb5-8011-4989-ae92-e34b9ba3094a.png)
* 新密码和确认密码比对
* 调用service完成更新



## 给对象赋值新思想

1.**原来**：原来是采用实体类中的set，get方法设置获取参数。

2.**构建器方法**：

### 构建器

**使用方法**

1.**标记注解**：在需要被调用构建器的实体类上面设置@Builder

2.**设置参数**：

* 实例对象调用builder()方法
* .AAA(BBB)的方式设置参数

![image.png](/assets/3ed9eaa6-5b06-4744-82a4-46fdbe400767.png)



3.
