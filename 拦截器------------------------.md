# 拦截所有请求——验证token

# 登录后的Token验证逻辑（全局验证）

登录了以后，后端如何识别这个请求时登录之后的用户申请的。

这里用的是生成Jwttoken的方式获取一个字符串，当作后续请求的令牌，以减少数据库的反复查询。

**实例**：这里有一个ProductController，它用于操作数据库里面的商品，他就需要用到这个技术

1.**正常编写查询方法**

2.**编写解析请求发过来的JWT**：

* 由于jwt是放在http请求体中的，而且是放在一个**特定的位置**，叫做**Authorization**,
* 因此咋方法中的参数中，要加入一个参数，一个获取Authorization字符串的参数，
* @RequestHeader(name="Authorization") String token
* 将这个参数解析出来
* Map<String ,Object> class=JwtUtil.parseToken(token);

3.**编写异常处理**：很可能出现解析失败的情况，这时就可以用一个try——catch包裹起来

* 在异常的区域写入**返回的状态码**
* response.setStatus(401);
* 编写返回的错误消息
* return result.error("未登录")

4.**编写Authorization**：这个**不是关键词**，

* **postman测试**：在请求头Header选项中编写authorization

### 升级版token验证

通过拦截器来验证，不用再每个方法中编写验证逻辑

1.**编写拦截器**：

* **实现 HandlerInterceptor方法**：由于是再方法实现之前验证，所以实现prehandler
* **获取token**：由于这个是放在header中的，header是在request中的。所以要从request中获取request.getHeader("Authorization")
* **解析Token**：如果解析成功，就**放行**，解析失败，就返回状态码。

2.**注册拦截器**：

* **新建文件**：config，用来写一个全局的配置WebConfig，所以新建一个WebConfig.java文件
* **实现接口**：WebMvcConfigurer
* **导入拦截器**：

  **第一步**：获取拦截器对象

  **第二步**：添加拦截器

  ![image.png](/assets/d7dffc25-fd76-49a9-9e05-83f706cf74ca.png)
* **编写拦截器细节**：某些请求不应该拦截，登录注册
* **编写排除方法**：在上面添加拦截器后面写排除拦截的路径。
* ![image.png](/assets/823d7d4d-be89-4294-8f1c-d883dea86dde.png)

3.**注册配置类**：在类上添加一个注解即可完成注册

* @Configuration

# 参数的传递

工具：**拦截器**，**本地线程工具类**

**流程**：有一些重复的代码，想搬到拦截器执行，执行后，想让controller获取到数据，就需要用到线程来传递

1.在pre拦截器，执行到想要的数据后

2.用线程工具来传递参数

![image.png](/assets/ae20e0e4-5c59-46fc-9d09-7e99cc8a6acd.png)

3.直接利用这个类来get到这个参数。

4.在after之后销毁线程
