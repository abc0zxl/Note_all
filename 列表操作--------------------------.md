# 杂碎问题

1.**IDEA中sql的属性快速补齐**：在sql映射文件中，sql语句的参数名字太多不好写，就会用快捷方法**提示补齐**，

字段自动提示：Settings -> Languages & Frameworks |-> SQL Dialects    把两个都改成mysql

2.**批量插入数据库**：就是说service传递个mapper的参数是一个对象，仅仅在sql映射文件中展开插入操作

3.**service的单个方法的第二次数据库操作，需要第一次数据操作生成的id**：可以直接在第一个执行了mapper的语句后面获取id，因为他已经完成了数据库的操作，已经生成了id值。这里就需要用到了**主键回显**操作。这个具体的讲解在下面

# 分类表

这个逻辑还是比较复杂的

1.**创建一套属于Category的实现框架**：

2.**设置参数**：他是接受了一个对象，所以是@RequestBody

3.**编写其他的部分**：service，service接口，mapper

4.**注意对象参数逻辑**：初始设置时，肯定设置不了里面的**修改用户**，**修改时间**，

* 在service通过本地线程获取用户名字，
* 设置时间，注意接受时间的属性必须是LocalDateTime

5.**mapper样式**：一个一个导入的

![image.png](/assets/8b3dafc4-6390-420e-ae51-1da459a329a2.png)

## 分类表删除逻辑

这个需要关联到别的东西，比较复杂

* 该分类下是否还有商品，还有则不能删除
* 内部要先实现一个查询是否还有商品的操作，
* 然后判断是否要抛异常

# 获取列表

1.**编写controller**：返回类型是List集合

2.**编写service**：返回类型也是list集合

![image.png](/assets/c775f85f-201e-4dd4-b649-896d070c52ff.png)

3.**编写mapper**：它指向sql获取list集合

* select*from category where create_time=#{分类编号}。我这里是category_type

4.**设置日期格式**：@JsonFormat(pattern="yyyy-mm-dd hh:mm:ss")

# 分页列表查询

这个按照需求来，但是基础的参数有两个

* 分页条数
* 分页页码

这里因为要实现分类，和状态查询，所以多了两个

* 分类信息
* 状态信息

1.**创建controller方法**

* **编写参数**：由于后两个参数是非必须的所以可以用注解来声明它。@RequestParam(required=false)

2.**构建PageBean对象**：用于封装查询到的列表，这个实体类在项目SpringBoot_item中，自己找。

* 将Result的对象变为PageBean

3.**编写service**：、

* 创建pagebean对象
* **启动分页插件pageHelper**：这里是mybatis提供的一个工具PageHelper，在sql执行前执行就行

  **第一步**：引入依赖com.github.pagehelper

  **第二步**：在service中编写PageHelper.startPage(bageNum,pageSize)，service的具体内容看下面

  **第三步**：调用mapper，mapper需要三个参数，

4.**mapper参数**：

由于我设计的是一个猫粮管理系统，所以每个商户有自己的猫粮库存。所以需要在查询列表时根据用户id查找自己的列表即可。所以需要引入商品列表的用户id

5.**编写动态sql**：因为存在两个可能存在可能不存在的查询条件

* 动态sql比较复杂所以去xml的sql映射文件编写比较合适。
* **创建sql映射文件**：在resource下创建从java的下一级到mapper的路径
* sql语句利用**limit A,B**来获取对应页数
* **模糊查询**：用于查找商品的列表时用
* ![image.png](/assets/5157c043-afa1-4417-8008-eddcb1a59e27.png)

## 如何利用pageHelper

在service中，他的作用就是处理分页，sql不用管到底要取那几页。

sql只用关注条件获取列表就好了。

**实现步骤**

1.**创建pageBean对象**

2.**开启分页查询**

3.**在mapper中获取list集合**

4.**将list集合放到Page<>中**：因为pageBean的返回类型，需要返回一个page<>对象。注意要强制转换一下

5.**向pageBean写入参数**：条目数，数据

6.**返回pageBean对象**：

![image.png](/assets/3f3011ee-abad-481f-84a4-e2aaa65a5a51.png)

**pageHelper如何实现的分页的计算并导入**：sql中就设置一个模糊查询，就完成了分页查询？，为什么sql没有分页的代码也能完成分页？他的内部不必细究，具体流程如下

* PageHelper是基于ThreadLoad实现的
* pagehelper的starter获取到了当前页码和页大小就自己主力计算出了sq中limit的起始位置，并存入到ThreadLocal中
* 具体调用我们不用操心，他帮我调用了，并放到了正确的位置。
* 在sql映射文件中设置了模糊查询的sql后，查询执行时，**pageHelper会自动执行一系列操作**将这个limit部分的sql语句拼接到sql映射文件的sql语句中。**所以完成了分页查询，而且我们也看不到**

## 复杂实体类的事务操作

就是说这个方法他必须是完整执行的，要么全部成功，要么全部失败，不能中途停下来。

**例子**：遇到一个方法中要处理两张表的情况，一个实体类中某个属性他的类型又是另一个实体类。所以要把这个方法声明为**事务**

**实现步骤**：

1.**开启事务注解**：在启动类方法上面加入@EnableTransactionManagement

2.**加入事务处理注解**：@Transacctional

3.**判断传入的对象中的二级实体类是否为空**：这个作为是否执行二级实体类数据库操作的标准

## 导入多个不确定数量的数据

**例如**：菜品他的口味是通过客户来选择的，可能有一个可能有很多个，这就需要导入同一个菜品id，多个口味的数据。

因为菜品是先导入的，所以可以获取他的id

下面是如何获取id的场景

#### 获取sql执行后自动生成的id

可以从从执行了mapper后，get到这个对象的id。这个步骤如下

**获取方法**：

1.**在sql映射文件中加入命令**：这个就是模板

![image.png](/assets/3d8ff15f-b08e-4ba3-b36a-7969efc4d51d.png)

2.**get获取id**：原来传递给mapper的那个对象。在执行完mapper后，直接执行这个对象的get他的Id的方法，就能获取到id

#### 将二级实体类获取出来

1.**获取数据1**：因为上面的二级实体类他在一级实体类中是一个list集合

2.**获取数据2**：所以可以直接将这部分数据获取到list集合中类型就是这个口味的类型

3.**循环插入数据**：

* 先将这个口味对象的ID数据在插入之前set进去，
* 在将口味信息插入到数据库中。

![image.png](/assets/7ef4845d-5cca-42a2-a416-646225aa570d.png)

## VO思想

VO，View Object视图对象，这个是用于数据返回到前端的一个对象。

* 列表查询
* 数据回显
