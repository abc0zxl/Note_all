# 自定义注解

#### 实体参数的校验

当传递的参数是一个对象时，就不能用原来在参数旁边的validation方法了，可以利用尸体参数校验的方法。

@NotNUull：表示这个参数不能为空

@NotEmpty：表示这个参数，以及string类不能为null

@Email：这个是邮箱的专属注解，也有非空的意思。

@Pattern:(regexp=""):这个是validation的方法，里面是正则表达式

**@URL**

**作用**：用于识别这个传过来的参数是不是一个合法的url地址

@Validated

如果不在实体类参数前面加这个注解的话，原来在实体中定义的校验方法,如@NotNull，@NotEmpty就不生效。

# 分组校验

更具不同的条件实行不同的校验标准

关键字：

* groups:
* 这个关键字是放到校验注解里面的如@NotNull,@NotEmpty,@Pattern,@JsonFormat
* 然后这个groups里面可以放多个分组。书写方式是AAA.class

**默认分组**：

* 就是那些没有声明分组的校验注解，
* 他们默认是全局生效的

**分组校验**：

* 一旦声明了分组，他就会单独，数据设定的分组群的校验
* 别的地方就不会生效这个校验

**使用步骤**

* 在实体类的下方编写一个接口，表示一个分组
* 讲后台需要实现分组校验的地方。用注解@Validated（AAA.BBB.class）声明一下，校验的条件，全用这个分组里的
* 在实体类中，讲要用到的校验，在疏解里面用group:BBB,接向这个分组，表示这个校验独属于这个分组
* 这样就实现了校验的分组

## 分组继承

* 当然如果就某个校验是单独属于某个接口的，
* 其他的公共校验还是要使用的话
* 可以讲这个分组接口继承Defult，实现其他没有分组的校验注解也导入进来。

![image.png](/assets/5f2d7707-bbba-49e0-b9f2-89e8352a32f3.png)
