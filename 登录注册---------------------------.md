### 注册功能

**输入**：用户名，密码，邮箱，手机号，再次输入密码

##### 注意register插入用户的操作

在service种需要加密密码，再去存储

**加密**：

* **用专用的工具类**：Md5Util

##### Mapper实现

1.**直接传入参数方式**：

* sql语句要注意声明一下要插入哪些参数，因为有些参数是后期添加的
* ![image.png](/assets/54449db4-700d-4870-ab89-e05059e43937.png)
* 这种方式比较生硬

2.**传入对象方式**：

## 测试功能

用postman

**步骤**

1.**创建工作空间**：左上角workspace

2.**创建名字**：一般就是这个项目名字

3.**导入测试用例**：这个项目是跟着别人做的，左上角import

## 加入参数校验功能

例如，密码的格式要求，电话号码的长度，名字的长度等

**技术**：原来的校验都是在前端进行的

1.前端校验方式

* 校验该数据请求是否要想后端发送
* 校验失败提示通过是否可视化来操作

**弊端**：不太安全，所以前后端都要做数据校验的逻辑

3.**后端**

这里提供了要给专门数据校验的框架Spring Validation

### Spring Validation

**步骤**：

1.**加入依赖**：starter-validation

2.**添加功能注解**：在Controller的参数前面添加注解@Pattern并配上需求就可以了

#### @Pattern参数

**例子**：![image.png](/assets/4eb9539c-5312-4ee1-969f-e5b9192d5a94.png)

他用的时正则表达式

* regexp:正则表达式写格式
* message:写错误返回信息
*

3.**在类上加入注解**：@Validated表示启用validated

4.会去控制台报错500

![image.png](/assets/6df7d74d-b551-443b-8641-2b43cb813d0e.png)

5.**由于这个异常错误信息还是在控制台**：不符合正常的读取，这就需要用到了**全局异常处理器**

### 全局异常处理器

**实现步骤**

1.创建一个专用文件夹：exception

2.创建类

3.**写注解**：在这个类上写一个注解@RestControllerAdvice表示这个是一个全局异常处理

![image.png](/assets/d31249fd-a3eb-4ea3-9614-d02a8022475a.png)

4.**方法注解**：在具体方法上写一个注解@ExceptionHandler(AAA.class)

表示要处理的异常标准是Exception.class

5.编写内部条件，异常有还是没有的逻辑

* 用到spring提供的工具类
* ![image.png](/assets/05174896-3544-4475-ac98-18516ef829cb.png)
* 有则返回左边的，没有返回右边的

# 登录

**登录逻辑**：

* 用户名密码匹配后
* 成功就跳转页面
* 失败就给对应的提示

内部逻辑

**token**：用户登录成功后会自动下发jwt令牌，在后续每次请求种，都需要将它放到header中。存放在一个名为Authorization的下面。

**未登录**：就会响应401

1.编写登录的代码，这个也需要validated判断一下

2.编写判断逻辑

* 用户名是否存在
* 密码是否正确

### 具体实现步骤

1.**编写controller**：现在controller中编写好功能，

**注意**：上面讲道理后台会返回一个token，所以返回类型是String

2.**将登录书写的密码进行加密**：因为后台存储的密码是加密的。

3..**编写判断逻辑**：先看用户名存不存在，在判断用户是否存在（密码对不对）

4.**密码判断逻辑**：Md5Util.getMD5String(password).equals(u.getPassword())。这里的U是通过用户名获取到的对象。

5**登录成功**

### 登录认证

登录后，其他的请求也许需要认证，这时就需要一个东西来当成令牌用，这个是服务器给的JWT。

**作用**：减少数据库的查询数据库次数

#### JWT

Json Web Token

是一种剪辑，自包含的格式，用于通信双方以json数据格式安全的传输。

**加密编码方式**：Base64，非加密方式

**JWT有三部分**：

* **头**：加密方式，算法。
* **载荷**：被加密的信息。不要将密码放进来
* **签名**：数字签名，是前两部分的组合

#### 实现步骤

1.**加入依赖**：

* java-jwt
* ![image.png](/assets/ea55b617-e19e-4daf-8ec3-74a9c25e9b90.png)
* starter-test

2.**获取JWT**：这个是后台创建的，也就是现在编写的后端。这个生成jwt有固定模板。

![image.png](/assets/f86397fc-69c7-4f9c-a8ec-1e5ea5a191e4.png)

#### 提供的有现成的方法来生成和解析token---JwtUtil工具类

**实现步骤**

1.**把工具类放到项目中**

2.**getToken**：获取token

![image.png](/assets/8582f112-b549-44c9-b1bf-efde724e3bf9.png)

3.**parseToken**：解析token

![image.png](/assets/2f8e5f51-d773-4ea5-8def-d99afb6ca6cd.png)

### 继续登录逻辑编写

1.返回Token给前端

在登录成功的return之前生成token给result，传递给前端![image.png](http://asset.localhost/C%3A%5CUsers%5CZhuanZ1%5CAppData%5CRoaming%5Ccom.codexu.NoteGen%2Farticle%2F%2Fassets%2F8582f112-b549-44c9-b1bf-efde724e3bf9.png)

# 优化JWT

由于JWT令牌加密的是用户ID和用户名，原来的JWT令牌，修改了密码后，就会生成新的令牌，需要将原来的JWT作废。

不然旧令牌依旧可以使用。

## 借助Redis来处理

**实现逻辑**：

1.**初次获得JWT令牌**：

2.**向Redis和浏览器各发一份**：

3.**发送请求**：浏览器携带JWT过来，后端从Redis也获取JWT令牌过来。比对两个令牌，若相同则允许这个请求。

4.**修改密码后获得新的JWT**：

5.**Redis更新JWT**

6.**循环到第三步**

一三一四哦~，我们会在一起吗？

![image.png](/assets/c7b9c44a-92a6-4937-b1bf-d67e97de613a.png)

## 实现步骤

1.**导入依赖**：starter-redis

2.**编写redis全局配置**：spring:data:redis:

* host:localhost
* port:6379

3.**调用API实现存取操作**：它存储一个键值对

4.**初始化一个对象**：StringRedisTemplate，注意要加@Autowried

5.**调用他的存储数据的方法**：获得一个数据存储操作的对象

ValueOperations<String,String> operations=stringRedisTemplate.opsForValue();

6.**存储数据**：operation.set(AAA,BBB);
